/// Program AdaptationMask.edp : 
/// construction of a "Mask" function to enforce the mesh adaptor to respect a minimum density in some regions 

include "Macros_StabFem.edp";

// reading mesh
mesh th = readmesh("mesh.msh");

fespace Vh(th,P2);fespace VhVh(th,[P2,P2]);
VhVh<complex> [Maskx,Masky];
Vh MaskEnvelope;

// reading parameters and constructing mask
string typeMask;
cout << "Enter Mask type [rectangle,ellipse,...] >> " ;
cin >> typeMask;
cout << typeMask << endl;
typeMask = "rectangle";
if(typeMask=="rectangle")
{
	// reading parameter for "rectangle" type
	real Xmin,Xmax,Ymin,Ymax,DX;
	cout << "Enter successively [Xmin,Xmax,Ymin,Ymax] >> " ;
	cin >> Xmin >> Xmax >> Ymin >> Ymax ;
	cout << Xmin << " ; " <<  Xmax << " ; " <<  Ymin << " ; " <<  Ymax << endl ;
	cout << "Enter DX (expected grid step) >> " ;
	cin >> DX ;
	cout << DX << endl ;
	// creating Mask function
	real Xc = (Xmin+Xmax)/2; real Lx = abs(Xmax-Xmin);real Yc = (Ymin+Ymax)/2; real Ly = abs(Ymax-Ymin);

//  First idea
//	MaskEnvelope = exp(-(x-Xc)^6/Lx^6)*exp(-(y-Yc)^6/Ly^6);
//	MaskEnvelope = (MaskEnvelope>1e-10)?MaskEnvelope:1e-10;

// Second (better) idea
func real MM(real x,real Xmin,real Xmax,real DX,real Sm) 
	{
		// NB Sm is a smoothing factor affecting the quality just outside of the box; Sm=20 seems to lead to good result in most cases
	 if(x<Xmin-Sm*DX)
	 	{ return 0; }
	 else if (x<Xmin)
	 	{ return cos(pi/2*(x-Xmin)/(Sm*DX))^4; }
	 else if(x<Xmax)
		{ return 1;}
	 else if (x<Xmax+Sm*DX)
	    { return cos(pi/2*(x-Xmax)/(Sm*DX))^4; }
	 else
	 	return 0;
	};
	 
//	for(real XX=-3; XX<3; XX=XX+.05)
//		{ cout << "Test XX = " << 	XX << " ; F = " << MM(XX,-1,1,.5) << endl;}; 
	   
	   
	MaskEnvelope = MM(x,Xmin,Xmax,DX,20)*MM(y,Ymin,Ymax,DX,20);


	[Maskx,Masky] = [MaskEnvelope*(cos(x/(10*DX))+1i*sin(x/(10*DX))),MaskEnvelope*(cos(y/(10*DX))+1i*sin(y/(10*DX)))];
};
// else if (other cases ...)


// Writing the data in a .ff2m file
{ 
	fespace pp1(th,P1);
	pp1<complex> MaskP1=Maskx;
	pp1<complex> Mask2P1=Masky;
	ofstream file(ffdatadir+"Mask.ff2m"); 
    file << "### Data generated by Freefem++ ; " << endl;
    file << "Adaptation Mask" << endl;
    file << "datatype MASK datastoragemode CxP2P2 " << endl;
	file << "P1c Maskx P1c Masky" << endl << endl ; 
	for (int j=0;j<MaskP1[].n ; j++)
		file << real(MaskP1[][j]) << endl << imag(MaskP1[][j]) << endl;
	for (int j=0;j<MaskP1[].n ; j++)	
		file << real(Mask2P1[][j]) << endl << imag(Mask2P1[][j]) << endl;
    file << endl;
}


// exports as well in ".txt" format (for subsequent usage by FreeFem)
{
    ofstream file2(ffdatadir+"Mask.txt");
    file2 << Maskx[];
}
