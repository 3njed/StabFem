//
//  PROGRAM Mesh.edp
//
//  Example of mesh generator for StabFem 
//
//  OUTPUT FILES :
// 		mesh.msh 			->  mesh in Freefem format
//		mesh.ff2m 		->  descriptor 
//      BaseFlow_guess.txt 	->  base flow used to start first newton iteration
//      BaseFlow.ff2m 	->  (ff2m format)
//
//	convention for boundary conditions :
//  1 = inlet ; 2 (and 21,22,23) = wall ; 3 = outlet ; 6 = axis

//  D. Fabre & J. Sierra, nov 30 2018


include "Params.edp"
include "Macros_StabFem.edp";

xinfm=-50.;
xinfv=100.;
yinf=50.;
x1m=-5.;
x1v=30.;
y1=2.5;
x2m=-15.;
x2v=50.;
y2=10;
ls=300;

n=1.8;
ncil=75;
n1=7;
n2=4;
ns=0.4;
nsponge=0.05;

cout << " Generation of an initial mesh for a 2D compressible cylinder" << endl;
cout << " Enter the dimensions xmin, xmax, ymax ? " << endl; 
cin >> xinfm >> xinfv >> yinf ;
cout << "Xmin = " << xinfm << " ; Xmax = " << xinfv << " ; ymax = " << yinf << endl;  

//cout << " Enter the dimensions of the inner domain x1_{L}, x1_{R}, y1 ? " << endl; 
//cin >> x1m >> x1v >> y1 ;
//cout << "X_L = " << x1m << " ; X_R = " << x1v << " ; y1 = " << y1 << endl;  

//cout << " Enter the dimensions of the middle domain x2_{L}, x2_{R}, y2 ? " << endl; 
//cin >> x2m >> x2v >> y2 ;
//cout << "X2_L = " << x2m << " ; X2_R = " << x2v << " ; y2 = " << y2 << endl;  

cout << " Enter the size of the sponge region " << endl; 
cin >> ls ;
cout << "Size of the domain = " << ls << endl;  

cout << " Enter the vertical density of the mesh OUTSIDE " << endl; 
cin >> n ;
cout << "Vertical density of the mesh = " << n << endl; 


cout << " Enter the density of the refinement around the cylinder " << endl; 
cin >> ncil ;
cout << "density around the cylinder = " << ncil << endl; 

//cout << " Enter the density of points in the inner domain, middle, outer and sponge zone andl alpha ? " << endl; 
//cin >> n1 >> n2 >> ns >> nsponge >> alpha ;
//cout << "n1 = " << n1 << " ; n2 = " << n2 << " ; ns = " << ns << "; nsponge = " << nsponge << " ; alpha = " << alpha << endl;  

real yside = yinf+ls;
real xinlet = xinfm-ls;
real xoutlet = xinfv+ls;
real RADIUS = .5;

border cylinder(t=0,pi){ x=RADIUS*cos(t);y=RADIUS*sin(t);label=2;}
//border cylref(t=0,2*pi){ x=(RADIUS+RR)*cos(t);y=(RADIUS+RR)*sin(t);label=999;}

border inlet(t=0,1){ x=xinlet;y=yside*(1-t);label=1;}
border axis1(t=0,1){ x=xinlet+(-2*RADIUS-xinlet)*t;y=0;label=6;}
border axis2(t=0,1){ x=2*RADIUS+(xoutlet-2*RADIUS)*t;y=0;label=6;}

border axis3(t=0,1){ x=-2*RADIUS+RADIUS*t;y=0;label=6;}
border axis4(t=0,1){ x=RADIUS+RADIUS*t;y=0;label=6;}

border outlet(t=0,1){ x=xoutlet;y=yside*t;label=3;}
border latsup(t=0,1){ x=xoutlet-(xoutlet-xinlet)*t;y=yside;label=3;} // label 3 : same conditions as at outlet

border internal(t=pi,0){y=2*RADIUS*sin(t); x= 2*RADIUS*cos(t);label=99;}
border internal2(t=-1,1){y=4*RADIUS;x=t*4*RADIUS;label=99;}


/////////////////////////////////////////////////////////////////////////////////
// plot(inlet(10)+latinf(10)+outlet(10)+latsup(10)+cylref(10)+cylinder(10)+a1(10)+a2(10)+a3(10)+a4(10));
                         /////// Just to check the borders
/////////////////////////////////////////////////////////////////////////////////
// Build a mesh 
//cout << "toto" << endl;
plot(axis3(RADIUS*ncil)+axis4(RADIUS*ncil)+cylinder(-ncil)
+internal(pi*2*RADIUS*sqrt(n*ncil)+10)+internal2(n*8*RADIUS)
+inlet(yside*n)+axis1((-RADIUS-xinlet)*n)+axis2((xoutlet-RADIUS)*n)
+outlet(2*yside*n)+latsup((xoutlet-xinlet)*n));

mesh th=buildmesh(axis3(RADIUS*ncil)+axis4(RADIUS*ncil)+cylinder(-ncil)
+internal(pi*2*RADIUS*sqrt(n*ncil)+10)+internal2(n*8*RADIUS)
+inlet(yside*n)+axis1((-RADIUS-xinlet)*n)+axis2((xoutlet-RADIUS)*n)
+outlet(2*yside*n)+latsup((xoutlet-xinlet)*n));


//IFMACRO(FREEFEMPLOTS,YES)
plot(th);
//ENDIFMACRO

savemesh(th,ffdatadir+"mesh.msh");


// FIRST AUXILIARY FILE for Stabfem : SF_Init.ff2m
{
            ofstream file(ffdatadir+"SF_Init.ff2m"); 
			file <<  "### Data generated by Freefem++ ; " << endl;
            file << "(Auxiliary file with information on initial mesh)" << endl;
            file << "problemtype 2DComp" << endl;
			file << "XInfMin, XinfP, YInf, x1m, x1v, y1, x2m, x2v, y2, ls, n, ncyl, n1 n2, ns, nsponge" << endl;
			file <<  xinfm  << endl << xinfv << endl << yinf << endl << x1m << endl << x1v << endl << y1 << endl << x2m << endl << x2v << endl << y2 << endl << ls << endl << n << endl << ncil << endl << n1 << endl << n2 << endl << ns << endl << nsponge << endl;
}


// SECOND AUXILIARY FILE  for Stabfem : mesh.ff2m
	SFWriteMesh(ffdatadir+"mesh.ff2m",th)

// THIRD AUXILIARY FILE for Stabfem : SF_Geom.edp
{
			ofstream file2("SF_Geom.edp"); 
			file2 << "// Description geometry (file automatically created ; to be included in the FreeFem programs)" << endl;
            file2 << " real SFGeomLengthscale = 1 ; // length scale for nondimensionalization" << endl ;
            file2 << " real SFGeomVelocityscale = 1 ; // velocity scale for nondimensionalization " << endl ;
}



/*
// CREATE A guess for the base flow (here starting from zero works very well)
 	fespace femp1(th,P1);
	fespace femp2xfemp2xfemp1(th,[P2,P2,P1,P1,P1]); ///   pres P1 + vel 2x P2 + temp P1 + dens P1
        femp2xfemp2xfemp1 [ux,uy,up,utemp,uro]=[1.0,0.0,1.0,1.0,1.0];
        real Re = 0;real nu=1; real Ma = 0.01; real gamma = 1.4; real Pr = 0.7; // these three are useless at this stage but required in the macros 
        
// Save in txt format (for FreeFem)        
      	{
      	ofstream file(ffdatadir+"BaseFlow_guess.txt");
	    file << ux[] << endl;
	    file <<  endl << 0 << endl;
      	}
      	
// Save in ff2m format (for StabFem)	    
	     SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",0);

//plot(th,cmm="Mesh",wait=1,ps="Mesh.eps");
*/



/*
fespace Xh(th,P2);
Xh DELTA=hTriangle;
plot(DELTA,value=1,fill=1);
real delta=DELTA(xinfv,0);
real Ret=100.0;
Xh REY=Ret*delta/DELTA;
REY=min(REY,Ret);
plot(REY,value=1,fill=1);
*/
/*
fespace Xh(th,P2);

Xh ampsponge;
ampsponge=AmpSponge;
plot(ampsponge,fill=1,value=1);


// SAVE THE MESH in mesh.msh file 
//savemesh(th,pht+"mesh.msh");


*/
