/// 
/// file Macros_StabFem.edp
///
/// This file contains the case-dependent Macros for boundary conditions and postprocessing output.
///
/// This file can be customized according to requirements but it must contain the following macros :
///
///
/// boundary conditions : 
/// macro BoundaryconditionsBaseFlow(du,u,v) 
/// macro BoundaryconditionsStability(u,v,symmetry)
///...
///
/// For post-processsing purposes :
/// macro SFWriteBaseFlow(filename,ux,uy,p,type,iter)
/// macro SFWriteMode(namefile,ux,uy,p,ev,shift,type,iter)
/// ...
///
/// NB: Never do in the middle of a macro a comment using //, it will end the macro. use /* */ instead

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
//Directories
load "MUMPS_seq" 
string ffdatadir = "./WORK/";
////////////////////////////////////////////////////////////////////////////////////////////
//int bcinlet=1,bcoutlet=3,bcnoslip=5,bcinfcondfirst=2,bcinfty=4;


macro BoundaryconditionsBaseFlow(du,u,v)
	on(21,22,23,24,25,du#x=0.0-u#x,du#y=0.0-u#y)+
	on(1,du#x=1.-u#x,du#y=0.0-u#y)+
     	on(4,du#y=0.0-u#y)
//EOM


macro BoundaryconditionsStability(u,v,symmetry)
    	on(21,22,23,24,25,u#x=0.0,u#y=0.0)+
	on(1,u#x=0.,u#y=0.0)+
     	on(4,u#y=0.0)
//EOM


macro Boundaryconditions(ux,uy,v1,v2,symmetry)
    	on(21,22,23,24,25,ux=0.0,uy=0.0)+
	on(1,ux=0.,uy=0.0)+
     	on(4,uy=0.0)
//EOM 

macro Dbis(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] // macro for rate-of-deformation tensor
//EOM

macro Forcex(u,surface)   
	int1d(th,surface)( u#p*N.x-2*nu*( [1,0]' * ( Dbis(u)*[N.x,N.y] )) )/*   */ 
//EOM
macro Forcey(u,surface)
	int1d(th,surface)( u#p*N.y-2*nu*( [0,1]'*  (Dbis(u)*[N.x,N.y]  )) ) /*   */
//EOM
macro Pressure(u,surface)
	int1d(th,surface)(u#p)/int1d(th,surface)( 1.)
//EOM




macro SFWriteMesh(filename,th)
{
     ofstream fileFF(filename);
     fileFF << "### MESH generated by Freefem++ ; " << endl;
     fileFF << "Mesh for the flow over a 2D cavity" << endl;
     fileFF << "datatype Mesh meshtype 2D" << endl;
	 fileFF << "int np int Ndof real deltamin real deltamax" ;
	 string PostProcessMeshDescription = " real deltaA real deltaB real deltaC real deltaD" ; /*description of customizable part*/
	 fileFF << PostProcessMeshDescription << endl << endl ;
     fespace femp1N(th,P1);
     fespace femp2xfemp2xfemp1N(th,[P2,P2,P1]);	  
     femp2xfemp2xfemp1N [uNx,uNy,uNp];
	 fileFF << th.nv <<  endl << uNx[].n << endl ;
 	 cout << "#### Mesh information :" << endl;  
     cout << "## Number of vertices    " << th.nv <<  endl;
	 cout << "## Number of DOF : " << uNx[].n << endl << endl;  
 	 femp1N delta = hTriangle;
	cout << "## delta min : " << delta[].min << endl;
	cout << "## delta max : " << delta[].max << endl;
	fileFF << delta[].min << endl;
	fileFF << delta[].max << endl;   
    /*Next is customizable part ; here determination of the grid size at several points */
    real[int] xprobe = [0,	2.5,	4,	10];
    real[int] yprobe = [.5, 	.5,	0,	0]; 
	cout << "## delta(0,.5) : ( boundary layer) : " << delta(xprobe(0),yprobe(0)) << endl ;
	cout << "## delta(2.5,.5) : ( sensitivity) : " << delta(xprobe(1),yprobe(1)) << endl ;
	cout << "## delta(4,0) : ( wake ) : " << delta(xprobe(2),yprobe(2)) << endl << endl ;
    cout << "## delta(10,0) : ( far wake ) : " << delta(xprobe(3),yprobe(3)) << endl << endl ;
	for(int ii = 0; ii<4;ii++){ fileFF << delta(xprobe(ii),yprobe(ii)) << endl ;}	
 
}; 	 
//EOM



macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	if(iter>=0)
	{
	fespace p1forff2m(th,P1);  
	p1forff2m xx,yy;
	xx=x;
	yy=y;
    p1forff2m ut,vt,pt,vort;
	ut=u#x;
	vt=u#y;
	pt=u#p;
	vort=dy(u#x)-dx(u#y); /* vorticity */
	p1forff2m psi,phi;  
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for a 2D-incompressible problem " << endl;
    file << "datatype BaseFlow datastoragemode ReP2P2P1 " << endl;
	file << "real Re P1 ux P1 uy P1 p P1 vort P1 psi real iter " ;
	string PostProcessBaseFlowDescription = " real Fwallx real Fwally real Fplatex real Fplatey real pbottom"; /* customizable output */ 
	file << PostProcessBaseFlowDescription << endl << endl ; 
	file << Re << endl;	
			for (int j=0;j<ut[].n ; j++) file << ut[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << pt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vort[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << psi[][j] << endl;
			file << iter << endl;
			/* custom part */
			file << Forcex(u,24) << endl;
			file << Forcey(u,24) << endl;
			file << Forcex(u,25) << endl;
			file << Forcey(u,25) << endl;
			file << Pressure(u,23) << endl;

	}
	};

//EOM
	

macro SFWriteMode(namefile,u,ev,shift,typeFlow,iter)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1); 
		 p1forff2m xx,yy;
		 xx=x;
		 yy=y;
    	 p1forff2m<complex> ux1,uy1,pp1,vort1;  		 
 		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "Eigenmode for a 2D-incompressible problem " << endl;
    	 file << "datatype Eigenmode datastoragemode CxP2P2P1 " << endl;
    	 string descriptionFF;
    	 if(typeFlow=="EigenModeD"||typeFlow=="HarmonicMode")
    	 	{  descriptionFF="real Re complex lambda complex shift int iter P1c ux1 P1c uy1 P1c p1 P1c vort1 real AEnergy complex Fwallx complex Fwally complex Fplatex complex Fplatey complex pbottom"; }
    	 else if(typeFlow=="EigenModeA") 
    	    {  descriptionFF="real Re complex lambda complex shift int iter P1c ux1Adj P1c uy1Adj P1c p1Adj P1c vort1Adj real AEnergyAdj complex FwallxAdj complex FwallyAdj complex FplatexAdj complex FplateyAdj complex pbottomAdj"; }
    	 else if(typeFlow=="SecondHarmonicMode") 
    	    {  descriptionFF="real Re complex lambda complex shift int iter P1c ux1 P1c uy1 P1c p1 P1c vort1 real AEnergy complex Fwallx complex Fwally complex Fplatex complex Fplatey complex pbottom"; }
	     file << descriptionFF << endl << endl ; 
		 file << Re  << endl << real(ev) << " " << imag(ev) << " " << real(shift) << " " << imag(shift) << " " << iter << endl << endl;
 		ux1=u#x;
		uy1=u#y;
		pp1=u#p;
		vort1=dy(u#x)-dx(u#y);
		
		for (int j=0;j<ux1[].n ; j++) file << real(ux1[][j]) << " " << imag(ux1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(uy1[][j]) << " " << imag(uy1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(pp1[][j]) << " " << imag(pp1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(vort1[][j]) << " " << imag(vort1[][j]) << endl;
		
		file << endl;
		if(typeFlow=="EigenModeD"||typeFlow=="EigenModeA")
		{
		cout << "#### customisable output for a mode in the WAKE OF A 2D BLUFF BODY : " << endl; 
		real AEnergyMode = sqrt(2*int2d(th)(abs(u#x)^2+abs(u#y)^2)); /* factor should be 4 because 2 half domains and time-average of (u1 e^iphi+cc) is 2 |u1|^2  */
		cout << "#   Amplitude (with definition of Mantic-Lugo) = " << AEnergyMode << endl;
		file << AEnergyMode << endl;
		/*complex LiftMode = Portance(u,"A"); 
		cout << "#   Fy = " << LiftMode << " exp( lambda t) + c.c. " << endl;
		file << real(LiftMode) << " " << imag(LiftMode) << endl;*/	
		}
		if(typeFlow=="HarmonicMode")
		{
		cout << "#### customisable output for a SC mode in the WAKE OF A 2D BLUFF BODY : " << endl; 
		real AEnergyMode = sqrt(int2d(th)(abs(u#x)^2+abs(u#y)^2));  /* here factor 1 because 2 half domaines and time-average of cos^2 and sin^2 = 1/2. */ 
		cout << "#   Amplitude (with definition of Mantic-Lugo) = " << AEnergyMode << endl;
		file << AEnergyMode << endl;
		/*complex LiftMode = Portance(u,"A"); 
		cout << "#   Fy = " << real(LiftMode) << " * cos( omega t) + " << -imag(LiftMode) << " * sin( omega t) + "  << endl;
		file << real(LiftMode) << " " << imag(LiftMode) << endl;*/
		}
		if(typeFlow=="SecondHarmonicMode")
		{
		cout << "#### customisable output for a HB-2 mode in the WAKE OF A 2D BLUFF BODY : " << endl; 
		real AEnergyMode = sqrt(int2d(th)(abs(u#x)^2+abs(u#y)^2));  /* here factor 1 because 2 half domaines and time-average of cos^2 and sin^2 = 1/2. */ 
		cout << "#   Amplitude (with definition of Mantic-Lugo) = " << AEnergyMode << endl;
		file << AEnergyMode << endl;
		/*complex DragMode = Trainee(u,"S"); 
		cout << "#   Fx = " << real(DragMode) << " * cos( 2 omega t) + " << -imag(DragMode) << " * sin( 2 omega t) + "  << endl;
		file << real(DragMode) << " " << imag(DragMode) << endl;*/
		}
		file << real(Forcex(u,24))  << " "<< imag(Forcex(u,24))  << endl;
		file << real(Forcey(u,24))  << " "<< imag(Forcey(u,24))  << endl;
		file << real(Forcex(u,25))  << " "<< imag(Forcex(u,25))  << endl;
		file << real(Forcey(u,25))  << " "<< imag(Forcey(u,25))  << endl;
		file << real(Pressure(u,23))<< " "<< imag(Pressure(u,23))<< endl;
		};
//EOM	



	
macro SFWriteDNSField(filename,u,typeFlow,iter)
	fespace p1forff2m(th,P1);  
	p1forff2m xx,yy;
	xx=x;
	yy=y;
    p1forff2m ut,vt,pt,vort;
	ut=u#x;
	vt=u#y;
	pt=u#p;
	/*vort=dy(u#x)-dx(u#y); 
	p1forff2m psi,phi;*/
/*	solve Laplace(psi,phi, solver = CG) */
/* 	= int2d(th)(dx(psi)*dx(phi)+dy(psi)*dy(phi)) */
/* 	- int2d(th)(-vort*phi) */
/* 	- int1d(th,bcinlet,bcoutflow,bclat,bcwall)((-N.x*ux+N.y*uy)*phi); */   
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << "DNS Snapshot for a 2D-incompressible problem " << endl;
    file << "datatype DNSField datastoragemode ReP2P2P1 " << endl;
	file << "real Re P1 ux P1 uy P1 p real it " ;
	string PostProcessBaseFlowDescription = "real Fx real Fy"; /* customizable output */ 
	file << PostProcessBaseFlowDescription << endl << endl ; 
	file << Re << endl;	
			for (int j=0;j<ut[].n ; j++) file << ut[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << pt[][j] << endl;
			file << iter << endl;
	
	cout << "#### customisable output for WAKE OF A 2D BLUFF BODY : " << endl; 
    /* Calcul de la trainee */
    real DragDNS =int1d(th,2,21,22,23)(u#p*N.x);/*-nu*int1d(th,2,21,22,23)( (2*dx(u#x)*N.x+(dx(u#y)+dy(u#x))*N.y));*/
	cout << "#    Fx =  " << DragDNS << endl; 
    file << DragDNS << endl ; 
    real LiftDNS = int1d(th,2,21,22,23)(u#p*N.y); /*-nu*int1d(th,2,21,22,23)( (2*dy(u#y)*N.y+(dx(u#y)+dy(u#x))*N.x))*/
	cout << "#    Fy =  " << LiftDNS << endl; 
    file << LiftDNS << endl ;
	};
//EOM
		

macro DNSTimeStatisticsINIT(namefile)
{
	ofstream fileforces(namefile+".txt",append);
    fileforces << "%% tps   Energie Energieprime Fwallx Fwally Fplatex Fplatey pbottom"  << endl;
				
    ofstream file(namefile+".ff2m",append);
    file << "### Data generated by Freefem++ ; " << endl;
    file << "DNS Time-series of a 2D-incompressible problem " << endl;
    file << "datatype TimeStatistics" << endl;
	file << "real tps real Energie real EnergiePrime real Fwallx real Fwally real Fplatex real Fplatey real pbottom " << endl;
}
//EOM

macro DNSTimeStatistics(namefile)

		real Energie = int2d(th)((uDNSx-1)^2+uDNSy^2);
		real Energieprime=0;
		
	if(imean==1)
	{
		u1mean[] += uDNSx[];
	};
	if(imean==2)
	{
		u1prime[] = uDNSx[]-u1mean[];
		Energieprime = int2d(th)(u1prime^2+u2prime^2);
		Energieprimemean += Energieprime;
	};
		

		cout << "iter " << it << " ; Energy " << Energie  << " ; Pressure bottom cavity = " << Pressure(uDNS,23) <<  endl;
			  
		{
			ofstream fileforces(namefile+".txt",append);
				fileforces << tps << " " << Energie << " " << Energieprime << " " 
				<< Forcex(uDNS,24)  << " " <<  Forcey(uDNS,24) << " "  << Forcex(uDNS,25) << " "  << Forcey(uDNS,25) << " " << Pressure(uDNS,23) << endl;
				
			ofstream file(namefile+".ff2m",append);
				file << tps << " " << Energie << " " << Energieprime << " "  
				<< Forcex(uDNS,24)  << " " <<  Forcey(uDNS,24) << " "  << Forcex(uDNS,25) << " "  << Forcey(uDNS,25) << " " << Pressure(uDNS,23) << endl;
		}
//EOM	



