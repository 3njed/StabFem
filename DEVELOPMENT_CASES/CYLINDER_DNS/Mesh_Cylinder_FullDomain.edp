/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////
///// 
/////                              MESH GENERATOR for a cylinder
/////
/////
/////			Adapted from a source from V. Citro, F. Giannetti & P. Luchini
/////
/////  			  DImensions correspond to mesh "C3" from Mantic-Lugo et al.
/////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////



include "Macros_StabFem.edp";

//load "iovtk"                       /// load library to write in vtk format
//load "BinaryIO"                 ////load libary to write the solution in binary form
// load "BinaryIO_64"
//load "UMFPACK64"         /////// loading sparsesolver


real RADIUS=0.5;         /////// Cylinder Radius
 


real n=0.5;                 
int ns=30; 

real xinlet=-20.;     
real xoutlet=40.; 
real yside=20.;            //lateral distance from cylinder center

/////////////////////////////////////////////////////////////////////////////////
//int bclat=4,bcinlet=1,bcoutflow=3,bcwall=2,bcaxis=6;
                         /////// label for boundary conditions  
/////////////////////////////////////////////////////////////////////////////////
// cylinder center is in (0,0)

border cylinder(t=0,2*pi){ x=RADIUS*cos(t);y=RADIUS*sin(t);label=bcwall;}
//border cylref(t=0,2*pi){ x=(RADIUS+RR)*cos(t);y=(RADIUS+RR)*sin(t);label=999;}

border inlet(t=1,-1){ x=xinlet;y=yside*t;label=bcinlet;}
//border axis1(t=0,1){ x=xinlet+(-RADIUS-xinlet)*t;y=0;label=bcaxis;}
//border axis2(t=0,1){ x=RADIUS+(xoutlet-RADIUS)*t;y=0;label=bcaxis;}
border outlet(t=-1,1){ x=xoutlet;y=yside*t;label=bcoutflow;}
border latsup(t=0,1){ x=xoutlet-(xoutlet-xinlet)*t;y=yside;label=bclat;}
border latinf(t=1,0){ x=xoutlet-(xoutlet-xinlet)*t;y=-yside;label=bclat;}



/////////////////////////////////////////////////////////////////////////////////
// plot(inlet(10)+latinf(10)+outlet(10)+latsup(10)+cylref(10)+cylinder(10)+a1(10)+a2(10)+a3(10)+a4(10));
                         /////// Just to check the borders
/////////////////////////////////////////////////////////////////////////////////
// Build a mesh 

plot(inlet(yside*n)+outlet(2*yside*n)+latsup((xoutlet-xinlet)*n)+cylinder(-ns)+latinf((xoutlet-xinlet)*n));

mesh th=buildmesh(inlet(yside*n)+outlet(2*yside*n)+latsup((xoutlet-xinlet)*n)+latinf((xoutlet-xinlet)*n)+cylinder(-ns));


plot(th,wait=0);

savemesh(th,"mesh.msh");


        {
			ofstream file("mesh.mshinfo"); 
			file << "Mesh for a sphere" << endl;
			file << "PROBLEM TYPE :" << endl;
			file << "2D" << endl;
			file << "PARAMETERS : " << endl;
			file << "R  Xmin Xmax Rmax" << endl;
			file <<  RADIUS  << endl << xinlet << endl << xoutlet << endl << yside  << endl;
		}


/// THEN WE COMPUTE THE GUESS FROM STOKES EQUATIONS
        
  //      fespace femp1(th,P1);
    //    fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
      //  femp2xfemp2xfemp1 [ux,uy,up]=[0,0,0];
	   // ofstream file("chbase_guess.txt");
	   // file << u1[] << endl;
	   // file <<  endl << 0 << endl;
		//exec("cp chbase_guess.txt chbase.txt");
	
	
//	femp1 u1P,u2P,pP;
//	femp1 yy,xx;
//	yy = y; xx= x;
//	u1P=u1;
//	u2P=u2;
//	pP=p;

// SAVE THE MESH in mesh.msh file 
savemesh(th,ffdatadir+"mesh.msh");

// FIRST AUXILIARY FILE for Stabfem : SF_Init.ff2m
{
            ofstream file(ffdatadir+"SF_Init.ff2m"); 
			file <<  "### Data generated by Freefem++ ; " << endl;
            file << "(Auxiliary file with information on initial mesh)" << endl;
            file << "problemtype 2D" << endl;
			file << "real R real Xmin real Xmax real Rmax" << endl;
			file <<  RADIUS  << endl << xinlet << endl << xoutlet << endl << yside  << endl;
}


// SECOND AUXILIARY FILE  for Stabfem : mesh.ff2m
	SFWriteMesh(ffdatadir+"mesh.ff2m",th)



// THIRD AUXILIARY FILE for Stabfem : SF_Geom.edp
{
			ofstream file2("SF_Geom.edp"); 
			file2 << "// Description geometry (file automatically created ; to be included in the FreeFem programs)" << endl;
            file2 << " real SFGeomLengthscale = 1 ; // length scale for nondimensionalization" << endl ;
            file2 << " real SFGeomVelocityscale = 1 ; // velocity scale for nondimensionalization " << endl ;
}





// CREATE A guess for the base flow (here starting from zero works very well)
 		fespace femp1(th,P1);
        fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
        femp2xfemp2xfemp1 [ux,uy,up]=[0,0,0];
        real Re = 0;real nu=1; // these two are useless at this stage but required in the macros 
        
// Save in txt format (for FreeFem)        
      	{
      	ofstream file(ffdatadir+"BaseFlow_guess.txt");
	    file << ux[] << endl;
	    file <<  endl << 0 << endl;
      	}
      	
// Save in ff2m format (for StabFem)	    
	     SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",0);
	     


