//include"Params_Conduct.edp";

	verbosity = 0;
	
	include "Macros_StabFem.edp" 
	
//	include "Params_Conduct.edp"; // mesh definition
	real Rhole=1;
	
	cout << "### Mesh generation for the flow across a single hole" << endl;
	
	real Rext;// = 15;
	real Lext;// = 15;

	real Rcav;// = 10;
	real Lcav;// = 10;
	
	real chi, ep ; // epaisseur	
	cout << " Enter value of chi ? " ;
	cin >> chi ;
	cout << " => chi = " << chi << endl; 
    cout << " Enter value of Rext, Lext, Rcav,Lcav ? " ;
	cin >> Rext ;
	cout << " => Rext = " << Rext << endl; 
    cin >> Lext ;
	cout << " => Lext = " << Lext << endl; 
    cin >> Rcav ;
	cout << " => Rcav = " << Rcav << endl; 
    cin >> Lcav ;
	cout << " => Lcav = " << Lcav << endl; 



	ep = 2*chi;
	int Ni = 2;

//	include "Params_BirdCall.edp"; // mesh definition




	//symetry axis
	border axis(t=-(Lcav+ep),Lext){x=t ;y=0; label=6;};
	
        //outlet
	border outlet(t=0,Rext-1){x=Lext; y=t; label=3;};
	
        //outlet
	border outletP(t=Rext-1,Rext){x=Lext; y=t; label=31;};
	
        //upperout
        border upperout(t=0,Lext){x=Lext-t; y=Rext; label=5;};
	
    //wallout
        border wallout(t=Rext,Rhole){x=0; y=t; label=2;};

        //wallb
        border wallb(t=0,ep){x=-t; y=Rhole; label=2;};
	
        //wallin
        border wallin(t=Rhole,Rcav){x=-ep; y=t; label=2;};
	
        //upperinlet
        border upperin(t=0,Lcav){x=-ep-t; y=Rcav; label=7;};

		//inlet
	border inlet(t=0,Rcav){x=-ep-Lcav; y=Rcav-t; label=1;};
	
	//Wake
//	border wake(t=Lin+b+e,Lin+Lout-1){x=t; y=0.75; label=8;};	

        	
	//PLOT

	plot(
	  axis(Ni*(Lext+Lcav+ep))  
	+ outlet(Ni*Rext) + upperout(Ni*Lext) 
	+ wallout(Ni*(Rext-Rhole)) + wallb(Ni*ep) 
	+ wallin(Ni*(Rcav-Rhole)) + upperin(Ni*Lcav) + inlet(Ni*Rcav) 
	, wait=1);

	//MESHING

	mesh th;
	th = buildmesh(  axis(Ni*(Lext+Lcav+ep))  
	+ outlet(Ni*Rext) + outletP(Ni) + upperout(Ni*Lext) 
	+ wallout(Ni*(Rext-Rhole)) + wallb(Ni*ep+1) 
	+ wallin(Ni*(Rcav-Rhole)) + upperin(Ni*Lcav) + inlet(Ni*Rcav) 
	);	


IFMACRO(FREEFEMPLOTS,YES)	
	plot(th, wait=1);
ENDIFMACRO

// SAVE THE MESH in mesh.msh file 
savemesh(th,ffdatadir+"mesh.msh");

 real SFGeomRext = Rext ; 
 real SFGeomLext = Lext ; 
 real SFGeomep = ep ; 
 real SFGeomRcav = Rcav ; 
 real SFGeomLcav = Lcav ;
 real SFGeomRhole = Rhole ;

// FIRST AUXILIARY FILE for Stabfem : SF_Init.ff2m
{
            ofstream file(ffdatadir+"SF_Init.ff2m"); 
            file <<  "### Data generated by Freefem++ ; " << endl;
            file << "(Auxiliary file with information on initial mesh)" << endl;
IFMACRO(MAPPINGS,YES)
        file << "problemtype AxiXRCOMPLEX" << endl;
ENDIFMACRO
IFMACRO(!MAPPINGS)
        file << "problemtype AxiXR" << endl;
ENDIFMACRO
            
			file << "real Rhole real Rext real Lext real Rcav real Lcav real ep " << endl;
			file <<  Rhole  << endl << Rext << endl << Lext << endl << Rcav << endl << Lcav << endl << ep  <<  endl;
			
}

real ParamMapLm = 1 ;real ParamMapLA = 1e10 ;real ParamMapLC = 1. ;real ParamMapGC = 0. ;real ParamMapyA = 1. ;real ParamMapyB = 1e10 ;
// SECOND AUXILIARY FILE  for Stabfem : mesh.ff2m
	SFWriteMesh(ffdatadir+"mesh.ff2m",th)


// THIRD AUXILIARY FILE for Stabfem : SF_Geom.edp
{
			ofstream file2("SF_Geom.edp"); 
			file2 << "// Description geometry (file automatically created ; to be included in the FreeFem programs)" << endl;
            file2 << " real SFGeomLengthscale = 2 ; // length scale for nondimensionalization" << endl ;
            file2 << " real SFGeomVelocityscale = 1 ; // velocity scale for nondimensionalization"  << endl ;
            file2 << " real SFGeomRext = " << Rext << " ; " << endl ; 
 			file2 << " real SFGeomLext = " << Lext << " ; " << endl ; 
 			file2 << "real SFGeomep = " << ep << " ; " << endl; 
			file2 << "real SFGeomRcav = " << Rcav << " ; " << endl; 
			file2 << " real SFGeomLcav = " << Lcav << " ; " << endl ;
			file2 << " real SFGeomRhole = " << Rhole << " ; " << endl;
}


//




// CREATE A guess for the base flow (here starting from zero works very well)
 		fespace femp1(th,P1);
        fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
IFMACRO(MAPPINGS,YES)
        femp2xfemp2xfemp1<complex> [ux,ur,up]=[0,0,0];
ENDIFMACRO
IFMACRO(!MAPPINGS)
        femp2xfemp2xfemp1 [ux,ur,up]=[0,0,0];
ENDIFMACRO
        real Re = 0.1;real nu=1; // these two are useless at this stage but required in the macros 
        
// Save in txt format (for FreeFem)        
      	{
      	ofstream file(ffdatadir+"BaseFlow_guess.txt");
	    file << ur[] << endl;
	    file <<  endl << 0 << endl;
      	}
      	
      	
// Save in ff2m format (for StabFem)	    
     SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",0);
	     




		cout << "............................................" << endl;
		cout << "............................................" << endl;
		cout << "Maillage termine " << endl << "..." << endl;
//		cout << "nombre de sommets: "+Th.nv << endl;
		cout << "............................................" << endl;
		cout << "............................................" << endl;


//
//	
//	exec("mkdir CHBASE");	
//	
//	savemesh(Thall,"CHBASE/mesh_Init.msh");
//	savemesh(Thall,"mesh_guess.msh");
//
//	fespace V1h(Thall,[P2,P2,P1]);
//	V1h [v,u,p];
//	u[]= 0;
//	V1h<complex> [vC,uC,pC];
//	uC[]= 0;
//		
//		
//	{
//		ofstream U("chbase_guess.txt");		
//		U << v[];
//	}
//	
//	{
//		ofstream U("chbase_guessCOMPLEX.txt");		
//		U << vC[];
//	}
//	
//	exec("cp chbase_guess.txt CHBASE/cbn_Init.txt") ;
//	
//	
//	plot(Thall, wait=0);
//
//	fespace p1(Thall,P1);
//	p1 yy,xx;
//	xx = real(xphys);
//	real xxmaxR = xx[].max;
//	xx = imag(xphys);
//	real xxmaxI = xx[].max;
//	yy = yphys;
//	real ymax = yy[].max;
//	
//	cout << " dimensions du domaine :  ( " 
//	<< xxmaxR << " + i " << xxmaxI << " ) x " << ymax << endl;
//	
//
//
//
