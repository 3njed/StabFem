
include "Macros_StabFem.edp";

mesh th= readmesh(ffdatadir+"mesh.msh");

real rho = 1;
real c = 1;
real Sin = int1d(th,2)(2*pi*x); // surface d'entrée
real Z0 = rho*c/Sin;// impedance carateristique du tuyau

complex Qin ;
//real k; // nombre d'onde k=omega*c0
		    
fespace VH(th,P1);
VH<complex> f,f1,ftrace;
VH fr,fi,ft,fabs;
complex Zin, Pin;

problem HelmholtzSOMMERFELD(f,f1) =
         int2d(th)( (-(dx(f)*dx(f1)+dy(f)*dy(f1))+k^2*f*f1)*2*pi*x ) // - grad (phi) * grad(phi1) dV 

       - int1d(th,2)(f1*2*pi*x)  // condition d'entr?e
	   + int1d(th,5)((1i*k-1/sqrt(x^2+y^2))*f*f1*2*pi*x) // condition de sortie de Sommerfeld (a utiliser pour les tuyaux) 
	   + int1d(th,6)(1i*k*f*f1*2*pi*x) // condition de sortie d'onde plane (a utiliser pour les pots d'?chappements)
		  ;

problem HelmholtzCM(f,f1) =
         int2d(th)( JJ*(-(Dx(f)*Dx(f1)+Dy(f)*Dy(f1))+k^2*f*f1)*2*pi*Xphys(x,y,ParamMap) ) // - grad (phi) * grad(phi1) dV 

       - int1d(th,2)(f1*2*pi*x)  // condition d'entr?e

       //+ on(5,f=0);
	   //+ int1d(th,5)((1i*k-1/sqrt(Xphys(x,ParamMap)^2+Rphys(x,ParamMap)^2))*f*f1*2*pi*Xphys(x,ParamMap)); // condition de sortie de Sommerfeld (a utiliser pour les tuyaux) 
	   //+ int1d(th,6)(1i*k*f*f1*2*pi*Xphys(x,y,ParamMap)) // condition de sortie d'onde plane (a utiliser pour les pots d'?chappements)
		  ;

problem HelmholtzPML(f,f1) =
         int2d(th)( detJ*(-(S1(f)*S1(f1)+S2(f)*S2(f1))+k^2*f*f1)*2*pi*XphysPML(x,y,ParamMap) ) // - grad (phi) * grad(phi1) dV 

       - int1d(th,2)(f1*2*pi*x)  // condition d'entr?e

       //+ on(5,f=0);
	   //+ int1d(th,5)((1i*k-1/sqrt(x^2+y^2))*f*f1*2*pi*x); // condition de sortie de Sommerfeld (a utiliser pour les tuyaux) 
	   //+ int1d(th,6)(1i*k*f*f1*2*pi*XphysPML(x,y,ParamMap)) // condition de sortie d'onde plane (a utiliser pour les pots d'?chappements)
	   ;
/// Début du programme principal 

	real kmin,kmax,dk;
	int choixparam;	
	cout << "##################@################" << endl  
	     << "## PROGRAMME Impedance_loop.edp  ##" << endl 
	     << "###################################" << endl << endl;
//	cout << "Parametres de la boucle : saisie au clavier (choix 1) ou lecture dans un fichier (choix 0) ?" << endl;
//	cin  >> choixparam;
	     
//	     if(choixparam==1)
	     {
	     	cout << "Entrez successivement kmin, dk, kmax : " << endl;
	     	cin >> kmin >> dk >> kmax; 
	     }
	     {
	     	cout << "Entrez le type de condition de frontiere (SOMMERFELD,CM,PML) : " << endl;
	     	cin >> boundaryCondition; 
		 }

//	     else
//	     {
//	     	ifstream Input("Parameters_for_Impedance_loop.txt");  
//	        Input >> kmin >> dk >> kmax;
//	     };

	cout << endl << "BOUCLE avec kmin = " << kmin << " ; dk = " << dk << " ; kmax = " << kmax << endl;


	
	ofstream Res("Impedances.txt"); // declare un fichier de sortie qui s'appelle Res et correspond à Impedances.txt
	
	int Nb = (kmax-kmin)/dk+1;
	real[int] ktab(Nb);
	complex[int] Ztab(Nb);
	real[int] Reflexion(Nb);
	
	for(int index = 0; index<Nb; index++)
	{
	k= kmin+index*dk;	

	if (boundaryCondition == "SOMMERFELD")
	{
		HelmholtzSOMMERFELD;
	}
	else if (boundaryCondition == "CM")
	{
		HelmholtzCM;
	}
	else if (boundaryCondition == "PML")
	{
		HelmholtzPML;
	}
	else
	{
		cout << "No boundary condition implemented with this name. End of program." << endl;
	}
	
	Pin = -rho*c*1i*k*int1d(th,2)(2*pi*x*f)/Sin;
	Qin = int1d(th,2)(-2*pi*x*dy(f));
	Zin = Pin/Qin;
	
	ktab(index) = k;
	Ztab(index) = Zin;
	Reflexion(index) = abs((Zin-Z0)/(Zin+Z0))^2;
	
	cout << " k " << k << " ; Zin " << Zin  << " ; Ref = " << Reflexion(index) << endl;
	Res << k << " " << real(Zin) << " " << imag(Zin) << " " << abs(Zin) << " " << Reflexion(index) << " " << 1-Reflexion(index) <<  endl; 

	 
	} 

		{
		ofstream file(ffdatadir+"AcousticImpedances.ff2m");
		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "Impedance" << endl;
    	 file << "Format :" << endl;
    	 string descriptionFF;
    	 descriptionFF = " real."+Nb+" k " + " complex."+Nb+" Z "+" real."+Nb+" R "; 
	     file << descriptionFF << endl << endl ; 
		for(int j=0;j<Nb;j++) { file << ktab(j) << endl;};
		for(int j=0;j<Nb;j++) { file << real(Ztab(j)) << " " << imag(Ztab(j)) << endl;};
		for(int j=0;j<Nb;j++) { file << Reflexion(j)  << endl;};
		}

 
 
