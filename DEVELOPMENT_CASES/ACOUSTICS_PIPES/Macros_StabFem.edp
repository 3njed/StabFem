
string ffdatadir = "./WORK/";

IFMACRO(!problemtype)
macro problemtype "AcousticAxi"//EOM
ENDIFMACRO

string boundaryCondition = "SOMMERFELD";

// Aritificial Boundary conditions 

real D = 15;
real DPML = 15;
real RPML = 5;
real R = 5;
real Lc = D;
func radius = sqrt(x^2+y^2);
complex k = 0.01; // I define k here because I will use it in the macros
func om = (k<1)?max(real(k),0.01):1;

macro Hx(x,y,ParamMap) 
    (
    (radius<R || y<0)?1:
    (radius>R && y>0)*
    (1.0/( 1+1i*abs((4*abs(x)/radius*(radius-R)/Lc^2*(1.0-(tanh((radius-R)^2/Lc^2))^2)/(om)))))
    )//EOM

 macro Hy(x,y,ParamMap) 
    ( 
    (radius<R || y<0)?1:
    (radius>R && y>0)*
    (1.0/( 1+1i*abs((4*abs(y)/radius*(radius-R)/Lc^2*(1.0-(tanh((radius-R)^2/Lc^2))^2)/(om)))))
  )//EOM

macro Xphys(x,y,ParamMap) 
    (
    (radius<R || y<0)?x:(radius>R && y>0)*(R*cos(atan(y/(x+1e-8))) + 1i/om*cos(atan(y/(x+1e-8)))*tanh((radius-R)^2/Lc^2))
    )//EOM

macro Rphys(x,y,ParamMap) 
    (
    (radius<R || y<0)?y:(radius>R && y>0)*(R*sin(atan(y/(x+1e-8))) + 1i/om*sin(atan(y/(x+1e-8)))*tanh((radius-R)^2/Lc^2))
    )//EOM

macro Dx(a) Hx(x,y,ParamMap)*dx(a) //EOM
macro Dy(a) Hy(x,y,ParamMap)*dy(a) //EOM
    
// Jacobian of the coordinate change
macro JJ 1/(Hx(x,y,ParamMap)*Hy(x,y,ParamMap)) //EOM

complex gamma=1.0*(1.0+1i);
func sig = (radius>RPML && y>0)?gamma/max(real(k),0.0001)/DPML^2*abs(radius^2-RPML^2):0.0;
func alpha = 1.0/(1.0+sig);
func detJ = 1.0+sig;
func Jm11 = (alpha*x^2+y^2)/(x^2+y^2);
func Jm12 = (alpha-1.0)*x*y/(x^2+y^2);
func Jm21 = (alpha-1.0)*x*y/(x^2+y^2);
func Jm22 = (x^2+alpha*y^2)/(x^2+y^2);
// Variational formulation
macro S1(u) (Jm11*dx(u)+Jm21*dy(u)) // EOM
macro S2(u) (Jm12*dx(u)+Jm22*dy(u)) // EOM
macro XphysPML(x,y,ParamMap) 
    (
    (radius<RPML || y<0)?x:(radius>RPML && y>0)*(RPML*cos(atan(y/x)) + gamma/(k*DPML^2)*(radius^3-RPML^2*radius+2/3*RPML^3)*cos(atan(y/x)) )
    )//EOM


macro SFWriteMode(namefile,u,k,Z)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1); 
		 p1forff2m xx,yy;
		 xx=x;
		 yy=y;
    	 p1forff2m<complex> phiC;
    	  
    	/*  field on the axis */ 
    	VH<complex> pp = 1i*k*f;
        VH<complex> u = dy(f);
        int Naxis = 501;
        complex[int] ppaxis(Naxis),uaxis(Naxis);
        real[int] Xaxis(Naxis);
        int index=0;
        for(real zz=yy[].min; zz<yy[].max; zz=zz+ (yy[].max-yy[].min)/500)
        {
        ppaxis(index) = pp(0,zz); 
        uaxis(index) = u(0,zz);
        Xaxis(index) =zz;
        index++; 
        }
        Naxis = index; 	  		 
 		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "AcousticField" << endl;
    	 file << "Format :" << endl;
    	 string descriptionFF;
    	 descriptionFF="real k complex Z P1c Phi "; 
    	 descriptionFF=descriptionFF + " real."+Naxis+" Xaxis " + " complex."+Naxis+" Paxis "
    	                             + " complex."+Naxis+" Uaxis "; 
	     file << descriptionFF << endl << endl ; 
		 file << k  << endl << real(Z) << " " << imag(Z) << endl;
		phiC=u;
		for (int j=0;j<phiC[].n ; j++) 
        {
            file << real(phiC[][j]) << " " << imag(phiC[][j]) << endl;
		};
		file << endl;
		for(int j=0;j<Naxis;j++) { file << Xaxis(j) << endl;};
		for(int j=0;j<Naxis;j++) { file << real(ppaxis(j)) << " " << imag(ppaxis(j)) << endl;};
		for(int j=0;j<Naxis;j++) { file << real(uaxis(j)) << " " << imag(uaxis(j)) << endl;};
        }
        
//EOM	




macro SFWriteBaseFlow(filename)


    ofstream file(filename);
    {
    file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow" << endl;
    file << "Format : " << endl;    
    file << "real ZERO" << endl;
    file << 0 << endl;
    };
//EOM
    


macro SFWriteMesh(filename,TH)
{
     ofstream fileFF(filename);
     fileFF << "### MESH generated by Freefem++ ; " << endl;
     fileFF << "Mesh for the acoustic irrotational flow" << endl;
     fileFF << "datatype Mesh meshtype 2D" << endl;
	 fileFF << "int np int Ndof real deltamin real deltamax" ;
	 string PostProcessMeshDescription = " real deltaA real deltaB real deltaC real deltaD" ; /*description of customizable part*/
	 fileFF << PostProcessMeshDescription << endl << endl ;
     fespace femp1N(TH,P1);
     fespace femp2xfemp2xfemp1N(TH,[P2,P2,P1]);	  
     femp2xfemp2xfemp1N [uNx,uNy,uNp];
	 fileFF << TH.nv <<  endl << uNx[].n << endl ;
 	 cout << "#### Mesh information :" << endl;  
     cout << "## Number of vertices    " << TH.nv <<  endl;
	 cout << "## Number of DOF : " << uNx[].n << endl << endl;  
 	 femp1N delta = hTriangle;
	cout << "## delta min : " << delta[].min << endl;
	cout << "## delta max : " << delta[].max << endl;
	fileFF << delta[].min << endl;
	fileFF << delta[].max << endl;   
    /*Next is customizable part ; here determination of the grid size at several points */
    real[int] xprobe = [0,	2.5,	4,	10];
    real[int] yprobe = [.5, 	.5,	0,	0]; 
	cout << "## delta(0,.5) : ( boundary layer) : " << delta(xprobe(0),yprobe(0)) << endl ;
	cout << "## delta(2.5,.5) : ( sensitivity) : " << delta(xprobe(1),yprobe(1)) << endl ;
	cout << "## delta(4,0) : ( wake ) : " << delta(xprobe(2),yprobe(2)) << endl << endl ;
    cout << "## delta(10,0) : ( far wake ) : " << delta(xprobe(3),yprobe(3)) << endl << endl ;
	for(int ii = 0; ii<4;ii++){ fileFF << delta(xprobe(ii),yprobe(ii)) << endl ;}	
 
}; 	 
//EOM


macro SFWriteForced(namefile,f,ev)
         {
         ofstream file(namefile);
         fespace p1forff2m(th,P1); 
         p1forff2m xx,yy;
         xx=x;
         yy=y;
         /*  field on the axis */ 
         VH<complex> p = 1i*k*f;
         VH<complex> u = dy(f);
         int Naxis = 501;
         complex[int] ppaxis(Naxis),uaxis(Naxis);
         real[int] Xaxis(Naxis);
         int index=0;
         p1forff2m<complex> phiC;

         file << "### Data generated by Freefem++ ; " << endl;
         file << "FORCED LINEAR RESPONSE for an axisymmetric acoustic " << endl;
         file << "datatype " << "ForcedFlow" << " datastoragemode CxP1 " << endl;
         string descriptionFF;
         descriptionFF="complex Lambda P1c u P1c p complex Z "; 
         descriptionFF=descriptionFF + " real."+Naxis+" Xaxis " + " complex."+Naxis+" Paxis "
                             + " complex."+Naxis+" Uaxis "; 

        
         file << descriptionFF << endl << endl ; 
         file << real(ev) << endl << imag(ev) << endl << endl;
        
        for (int j=0;j<u[].n ; j++) file << real(u[][j]) << endl << imag(u[][j]) << endl;
        for (int j=0;j<p[].n ; j++) file << real(p[][j]) << endl << imag(p[][j]) << endl;
        
        cout << "#### customisable output for LINEAR FORCED RESPONSE OF POTENTIAL ACOUSTICS : " << endl; 

        complex Rate = 2*pi*int1d(th,2)(u*y);
        complex Force = 2*pi*int1d(th,2)(y*p);
        complex pin = Force/(2*pi*int1d(th,2)(y)); 
        complex ZZ = (pin/Rate);
        cout << "#   Z = " << ZZ << endl;
        file << real(ZZ) << endl << imag(ZZ) << endl;  

        for(real zz=yy[].min; zz<yy[].max; zz=zz+ (yy[].max-yy[].min)/500)
        {
        ppaxis(index) = pp(0,zz); 
        uaxis(index) = u(0,zz);
        Xaxis(index) =zz;
        index++; 
        }
        Naxis = index;           
        for(int j=0;j<Naxis;j++) { file << Xaxis(j) << endl;};
        for(int j=0;j<Naxis;j++) { file << real(ppaxis(j)) << " " << imag(ppaxis(j)) << endl;};
        for(int j=0;j<Naxis;j++) { file << real(uaxis(j)) << " " << imag(uaxis(j)) << endl;};         
        };
//EOM   