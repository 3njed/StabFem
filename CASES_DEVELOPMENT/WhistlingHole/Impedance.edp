//
//  PROGRAM Impedance.edp
//  computation of a linear harmonically forced problem for the flow across a hole, for a single value (real) of omega. 
//
//  The parameters of the complex mapping (ParamMap###) are defined in a file "Param_Mapping.edp" 
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	omega
//	INPUT FILES :
//		BaseFlow.txt	-> base flow 
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		ForcedFlow_Re##_Omega##.txt	 and .ff2m	-> linear response
//
// 	ERROR MANAGEMENT : 
//
//  First version : sometime around 2014 ; Redesigned and incorporated in the project in september 2018.


cout << "$$$$ ENTERING Impedance.edp " << endl << "$$" << endl; 

include "SF_Geom.edp"; // contains a number of geometrical parameters characterizing the mesh
include "Param_Mapping.edp"; // contains the parameters of the complex mapping
include "Macros_StabFem.edp"; // contains a number uf useful macros : boundary conditions, post-processing, mappings, etc...
	real omega;
	cout << " Entrez omega (reel) :" << endl;
	cin >> omega ;
	cout << "omega = " << omega	<< endl;

		
	int Nprof =6;
	macro Uin(rr) ( (2+Nprof)/Nprof*(1-rr^Nprof) )  //EOM
	
	mesh th=readmesh(ffdatadir+"mesh.msh");
 	fespace p2xp2xp1(th,[P2,P2,P1]);
 	fespace p2(th,P2);
	fespace p1(th,P1);	
 	fespace p2xp2xp2xp1(th,[P2,P2,P2,P1]);
	p2xp2xp1<complex> [uxp,urp,upp];
    p2xp2xp1<complex> [ux,ur,up],[vx,vr,q];
    p2xp2xp1 [urr,uxr,pr],[uri,uxi,pii];
    
	int m=0; 
	real nu,Re;
	real epsilonPQ = 0*1e-20; // terme de desingularisation
	//	real S = (Rin/a)^2;
	real S = 100.;
	real Q = 1.;

	{
	ifstream cbin(ffdatadir+"BaseFlow.txt");
	cbin >> urp[];
	cbin >> Re;
	};
	cout << " Lecture BaseFlow : Re = " << Re << endl;
	
nu=2*SFGeomRhole/Re;
	
	

	problem PulsedJet([ux,ur,up],[vx,vr,q],eps=1e-16) = 
	int2d(th)(
	(
	- Rphys(y,ParamMap)*vx*(
		(uxp*dX(ux)+ux*dX(uxp)+urp*dY(ux)+ur*dY(uxp))	
		  -1i*omega*ux )  				
	- Rphys(y,ParamMap)*vr*(
		(uxp*dX(ur)+ux*dX(urp)+urp*dY(ur)+ur*dY(urp))	
		-1i*omega*ur )	
	- nu*(Rphys(y,ParamMap)*dX(ux)*dX(vx)+Rphys(y,ParamMap)*dY(ux)*dY(vx)  
	+ Rphys(y,ParamMap)*dX(ur)*dX(vr)+Rphys(y,ParamMap)*dY(ur)*dY(vr)+1/Rphys(y,ParamMap)*ur*vr  )  
	+ up*(Rphys(y,ParamMap)*dX(vx)+vr+Rphys(y,ParamMap)*dY(vr))
	- q*(Rphys(y,ParamMap)*dX(ux)+ur+Rphys(y,ParamMap)*dY(ur))
	)*1/(Hy(y,ParamMap)*Hx(x,ParamMap))
	)
	+ on(1,ux=Q/S,ur=0.)
  	+ on(2,ux=0.,ur=0.)	
	+ on(6,7,ur=0.) // axis and lateral boundary of cavity 
	; 
	


{


	cout << " Calcul d'une impedance pour un trou ; Re    = " << Re << endl; 
	cout << "                                       nu    = " << nu << endl;
	cout << "                                       omega = " << omega << endl;	

	PulsedJet;

//	{ofstream file("UVP_conductivity_Re"+Re+"_omega"+omega+".txt");
//  	file << ur[] ;	
//   	file << endl << endl << Re << endl;}
	


	complex Rate = 2*pi*int1d(th,1)(ux*y);
	complex Force = 2*pi*int1d(th,1)(y*up);
	complex pin = Force/(2*pi*int1d(th,1)(y)); // force/surface
	
	real Energy = int2d(th)(Rphys(y,ParamMap)/abs(Hy(y,ParamMap)*Hx(x,ParamMap))*(abs(ux)^2+abs(ur)^2));

	complex Imp = (pin/Rate);
 	complex K   = -1i*omega/Imp; 

	cout << ">>>> JET PULSE :  omega = " << omega << endl;
	cout << "Debit Q = " << Rate << endl;
	cout << "FORCE   = " << Force << endl;
	cout << "DeltaP (= Pression  entree) = " << pin << endl;
	cout << "IMPEDANCE = P/Q = " << Imp << endl;
	cout << "Conductance = " << K << endl;
	cout << "Delta, Gamma : " << real(K)/2 << " " << -imag(K)/2 << endl;
	cout << "Energie : " << Energy << endl; 
	

	
 	{
 	ofstream file(ffdatadir+"ForcedFlow_Re"+Re+"_Omega"+omega+".txt"); // file in .txt format for FreeFem solvers
	file << ur[]; 
	file << endl << endl << Re;
	}; 
	
	SFWriteForced(ffdatadir+"ForcedFlow_Re"+Re+"_Omega"+omega+".ff2m",u,1i*omega)


	// Sortie des critÃ¨res (OBSOLETE ?)
	ofstream file2(ffdatadir+"Impedance_Chi"+SFGeomep/(2*SFGeomRhole)+"_Re"+Re+"_omega"+omega+".txt",append);
	file2  	<< omega << " "
	    	<< real(K/2) 		<< " " << -imag(K/2) 	<< " "  << abs(K)	<< " " 	
		<< real(Imp) 		<< " " << imag(Imp) 	<< " "  << abs(Imp)	<< " " 
		<< -imag(Imp)/(omega+1e-10) 		<< " " << Re 	<< endl;
		
		
cout << "$$ LEAVING Impedance.edp " << endl << "$$" << endl; 		

};

	
	


	
	
