//
//  PROGRAM LoopImpedance.edp
//  computation of a linear harmonically forced problem for the flow across a hole, for a range of (real) omega. 
//
//  The parameters of the complex mapping (ParamMap###) are defined in a file "Param_Mapping.edp" 
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	omegamin, omegastep, opegamax
//	INPUT FILES :
//		BaseFlow.txt	-> base flow 
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		Impedance_Chi##_Re###.txt and .ff2m	-> impedance
//
// 	ERROR MANAGEMENT : 
//
//  First version : sometime around 2014 ; Redesigned and incorporated in the project in september 2018.

cout << "$$$$ ENTERING LoopImpedance.edp " << endl << "$$" << endl; 

include "SF_Geom.edp";
include "Param_Mapping.edp";
include "Macros_StabFem.edp";
	real omegamin,omegamax,omegastep;
	cout << " Entrez omegamin, omegastep,  omegamax :" << endl;
	cin >> omegamin >> omegastep >> omegamax ;
	cout << "Boucle omegamin = " << omegamin << 
	        " , omegastep = " << omegastep << " , omegamax = " << omegamax	<< endl;


 int NNN = 1000;	
 real[int] omegaTAB(NNN), EnergyTAB(NNN);
 complex[int] ImpTAB(NNN), RateTAB(NNN);		
		
	int Nprof =6;
	macro Uin(rr) ( (2+Nprof)/Nprof*(1-rr^Nprof) )  //EOM
	
	mesh th=readmesh(ffdatadir+"mesh.msh");
 	fespace p2xp2xp1(th,[P2,P2,P1]);
 	fespace p2(th,P2);
	fespace p1(th,P1);	
 	fespace p2xp2xp2xp1(th,[P2,P2,P2,P1]);
	p2xp2xp1<complex> [uxp,urp,pp];
    p2xp2xp1<complex> [ux,ur,up],[vx,vr,q];
    p2xp2xp1 [urr,uzr,pr],[uri,uzi,pii];
    
	int m=0; 
	real nu,Re;
	real epsilonPQ = 0*1e-20; // terme de desingularisation
	real omega;
//	real S = (Rin/a)^2;
	real S = 100.;
	real Q = 1.;

	{
	ifstream cbin(ffdatadir+"BaseFlow.txt");
	cbin >> uxp[];
	cbin >> Re;
	};
	cout << " Lecture BaseFlow : Re = " << Re << endl;
	
	nu=2*SFGeomRhole/Re;
	

	problem PulsedJet([ux,ur,up],[vx,vr,q],eps=1e-16) = 
	int2d(th)(
	(
	- Rphys(y,ParamMap)*vx*(
		(uxp*dX(ux)+ux*dX(uxp)+urp*dY(ux)+ur*dY(uxp))	
		  -1i*omega*ux )  				
	- Rphys(y,ParamMap)*vr*(
		(uxp*dX(ur)+ux*dX(urp)+urp*dY(ur)+ur*dY(urp))	
		-1i*omega*ur )	
	- nu*(Rphys(y,ParamMap)*dX(ux)*dX(vx)+Rphys(y,ParamMap)*dY(ux)*dY(vx)  
	+ Rphys(y,ParamMap)*dX(ur)*dX(vr)+Rphys(y,ParamMap)*dY(ur)*dY(vr)+1/Rphys(y,ParamMap)*ur*vr  )  
	+ up*(Rphys(y,ParamMap)*dX(vx)+vr+Rphys(y,ParamMap)*dY(vr))
	- q*(Rphys(y,ParamMap)*dX(ux)+ur+Rphys(y,ParamMap)*dY(ur))
	)*1/(Hy(y,ParamMap)*Hx(x,ParamMap))
	)
	+ on(1,ux=Q/S,ur=0.)
  	+ on(2,ux=0.,ur=0.)	
	+ on(6,7,ur=0.) // axis and lateral boundary of cavity 
	; 
	

int ind=0;
for (real omegaS = omegamin ; omegaS < omegamax; omegaS=omegaS+omegastep)
{
omega  = omegaS;


	cout << " Calcul d'une impedance pour un trou ; Re    = " << Re << endl; 
	cout << "                                       nu    = " << nu << endl;
	cout << "                                       omega = " << omega << endl;	

	PulsedJet;

//	{ofstream file("UVP_conductivity_Re"+Re+"_omega"+omega+".txt");
//  	file << ur[] ;	
//   	file << endl << endl << Re << endl;}
	


	complex Rate = 2*pi*int1d(th,1)(ux*y);
	complex Force = 2*pi*int1d(th,1)(y*up);
	complex pin = Force/(2*pi*int1d(th,1)(y)); // force/surface
	
	real Energy = int2d(th)(Rphys(y,ParamMap)/abs(Hy(y,ParamMap)*Hx(x,ParamMap))*(abs(ux)^2+abs(ur)^2));

	complex Imp = (pin/Rate);
 	complex K   = -1i*omega/Imp; 

	cout << ">>>> JET PULSE :  omega = " << omega << endl;
	cout << "Debit Q = " << Rate << endl;
	cout << "FORCE   = " << Force << endl;
	cout << "DeltaP (= Pression  entree) = " << pin << endl;
	cout << "IMPEDANCE = P/Q = " << Imp << endl;
	cout << "Conductance = " << K << endl;
	cout << "Delta, Gamma : " << real(K)/2 << " " << -imag(K)/2 << endl;
	cout << "Energie : " << Energy << endl; 
	

	omegaTAB(ind) = omega;
	RateTAB(ind) = Rate;
	ImpTAB(ind) = Imp;
	EnergyTAB(ind) = Energy;
	ind++;

	// Sortie des critÃ¨res
	ofstream file2(ffdatadir+"Impedance_Chi"+SFGeomep/(2*SFGeomRhole)+"_Re"+Re+".txt",append);
	file2  	<< omega << " "
	    	<< real(K/2) 		<< " " << -imag(K/2) 	<< " "  << abs(K)	<< " " 	
		<< real(Imp) 		<< " " << imag(Imp) 	<< " "  << abs(Imp)	<< " " 
		<< -imag(Imp)/(omega+1e-10) 		<< " " << Re 	<< endl;

};

	
	

// Generates a second data file for the StabFem driver 
{ 
	ofstream file(ffdatadir+"Impedance_Chi"+SFGeomep/(2*SFGeomRhole)+"_Re"+Re+".ff2m"); 
    file << "### Data generated by Freefem++ ; " << endl;
    file << "Impedance as function of omega" << endl;
    file << "DataType IMPEDANCE" << endl;
    int NN = ind;
	file << "real." << NN << " Omega" << "  complex." << NN << " Z" << endl << endl ; 
	for (int j=0;j<ind ; j++) { file << omegaTAB(j) << endl;} ;
	for (int j=0;j<ind ; j++) {file  << real(ImpTAB(j)) << endl << imag(ImpTAB(j)) << endl;};
    file << endl;
}
	
cout << "$$$$ LEAVING LoopImpedance.edp " << endl << "$$" << endl; 
	
	
