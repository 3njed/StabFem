//
//  PROGRAM Newton_AxiSwirl.edp
//  computation of Axisymmetric base flow [ux,ur,uphi](x,y)
//   
//  THIS FILE IS ADAPTED FROM Newton_Axi.edp
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, ROTATION, POROSITY
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// INCORPORATED INTO THE STABFEM PROJECT BY D. FABRE ON A BUSY DAY AT UNIVERSITA DI SALERNO, 18 july 2017
// REwriten on october 2 2017 with macros.


		include "Macros_StabFem.edp";
		if(ncomponentsBF==2) 
		{ cout << "ERROR in Newton_AxiSWIRL :  for this solver the parameter ncomponentsBF should be 3 not 2 !" << endl;
		  cout << "Change this in Macro_StabFem.edm" < endl;
		  exit(-1);
		 } 

		
	     verbosity = 0;
		mesh th=readmesh(ffdatadir+"mesh.msh");
		
        fespace Xh(th,P2);       //f.e. space for veloecity components
		fespace Mh(th,P1);      //f.e space for pressure
		fespace XXMh(th,[P2,P2,P1]); // f.e. space for triplet [u,v,p]
		fespace XXXMh(th,[P2,P2,P2,P1]); // f.e. space for quadruplet [u,v,w,p]

		XXXMh [ux,ur,uphi,up];          ///////  -> unknown for the Navier-Stokes problem
		XXXMh [vx,vr,vphi,vp];          ///////  -> test function for Navier-Stokes
		XXXMh [upx,upr,upphi,upp];   	 ///////  -> buffer vector  to store previous iteration (Newton) 
		XXXMh [dux,dur,duphi,dup]; 		 ///////  -> increment for the Newton iteration
	real Re;
	real Reans,lecture;
		XXMh [uaxix,uaxir,uaxip];          ///////  -> unknown for the Navier-Stokes problem

	real Omegax;
	real Porosity;
	real Uinfx = 1;
	cout << " Entrer le Nombre de Reynolds :" << endl;
    cin >>  Re;
    cout << " Entrer le taux de rotation :" << endl;
    cin >>  Omegax;
    cout << " Entrer la porosite du disque :" << endl;
    cin >>  Porosity;
    if(Porosity==0){Porosity=1e-30;};
    
    	int NdimUVP = uaxix[].n;
    	int NdimUVWP = ux[].n;
    	int NdimBaseFlow;
    	{
          ifstream file(ffdatadir+"BaseFlow_guess.txt");
          file >> NdimBaseFlow ;
    	}
		
		if(NdimBaseFlow == NdimUVP) 
		{
        cout << "Ndim = " << NdimUVP << " : reading UVP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> uaxix[];
        [ux,ur,uphi,up] = [uaxix,uaxir,0,uaxip];
		file >> Reans;
        }
        else if(NdimBaseFlow == NdimUVWP) 
        {
        cout << "Ndim = " << NdimUVWP << " : reading UVWP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> ux[]; 
		file >> Reans;
        }
        else 
        {
        cout << " Error : Wrong dimension For BaseFlow_guess.txt file" << endl;
        };


	cout << " Newton pour Re = " << Re << endl;	
	cout << " CI : " << Reans << endl; 
	real nu=1./Re;
	real eps = 1e-20; // may not be required


/////////////////////////////////////////////////////////////////////////////////
                         /////// macro to define some useful operators

macro div(im,u) (dx(u#x)+dy(u#r)+u#r/y+im/y*u#phi)// macro for divergence 
macro Grad(im,u) [
			[dx(u#x), dy(u#x),  im/y*u#x ], 
			[dx(u#r), dy(u#r),  im/y*u#r-u#phi/y],
			[dx(u#phi),dy(u#phi), im/y*u#phi+u#r/y ]
			] // macro for vecocity gradient tensor
macro D(im,u) [	
				[dx(u#x), 				.5*(dx(u#r)+dy(u#x)),  .5*(im/y*u#x+dx(u#phi)) ], 
				[.5*(dx(u#r)+dy(u#x)), 	dy(u#r),				.5*(im/y*u#r-u#phi/y+dy(u#phi))],
				[.5*(im/y*u#x+dx(u#phi)),  .5*(im/y*u#r-u#phi/y+dy(u#phi)), im/y*u#phi+u#r/y]
				] // macro for rate-of-deformation tensor
macro Conv(ima,ua,imb,ub,v) ( 
              (Grad(ima,ua)*[ub#x,ub#r,ub#phi] + Grad(imb,ub)*[ua#x,ua#r,ua#phi])'*[v#x,v#r,v#phi]
              			) // macro for mutual convection operator


//macro Diffusion(nu,u1,u2,v1,v2)  (-nu*( dx(u1)*dx(v1)+dy(u1)*dy(v1)+dx(u2)*dx(v2)+dy(u2)*dy(v2))) // integration by parts of (v * Delta (u) )  


//////////////////////////////////////////////////////////////////////////////////


cout << "IsInObject : " << IsInObject(1,1) << " " << IsInObject(.1,.25) << " " << IsInObject(2,2) <<  endl;

                         /////// linearized system
problem NewtonIter([dux,dur,duphi,dup],[vx,vr,vphi,vp]) =
    int2d(th)( 
			(
			-2*nu*(D(0,du):D(0,v))
             + vp*div(0,du)
             + div(0,v)*dup
				-Conv(0,up,0,du,v)
				-1/Porosity*IsInObject(x,y)*(dux*vx+dur*vr+duphi*vphi)
		     )*y
              )
             +
    int2d(th)(
		  (
    		-2*nu*(D(0,up):D(0,v))
             + vp*div(0,up)
             + div(0,v)*upp
             -.5*Conv(0,up,0,up,v)
             -1/Porosity*IsInObject(x,y)*(upx*vx+upr*vr+(upphi-Omegax*y)*vphi)
          )*y
              )
	+  BoundaryconditionsBaseFlow(du,up,v);     
    
    
// parameters for Newton loop            
    real tolerance=2e-12;
    int Nitermax=20;
    real ener=10;	
    int iter=0;
    
// Newton loop
        while((ener>tolerance)&(ener<50)&(iter<=Nitermax))
        {
	    upx[]=ux[];        ////// Uold=U
	    
	    
	    
        NewtonIter ;           //// update of current solution u1=u1-w
        
        
        plot(dux,fill=1,wait=0,value=1,cmm="dux");
        
        ux[] = ux[]+dux[];
		real enerl2=dux[].l2;
		ener=sqrt(int2d(th)(dux^2+dur^2+duphi^2)/th.area);
	    cout << " iter = "<< iter+1 << "   Re = " << Re << " res = " << ener << " ; res l2 = " << enerl2 << endl;
        iter++;
	  } ;



// sortie des résultats 

		if((ener>50)||(iter>Nitermax))
		{
			cout << " NEWTON ITERATION FAILED" << endl;
			exec("rm "+ffdatadir+"BaseFlow.txt");
			SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",-1,Porosity,Omegax);
		}
		else
		
		{
		  {ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
		  file << ux[]; 
		  file << endl << endl << Re;
		  }; 
          exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt"); 
          SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter,Porosity,Omegax); // file in .ff2ml format for StabFem driver
          // plot 
		  plot(ux,fill=1,wait=0,value=1,cmm="final U1");
		  plot(uphi,fill=1,wait=0,value=1,cmm="final U2");
		  Mh uphiphi = uphi;
		  cout << "Uphi max : " << uphi[].max;
			//plot(p,fill=1,wait=0,value=1,cmm="final Pressure");
    
		};
          
