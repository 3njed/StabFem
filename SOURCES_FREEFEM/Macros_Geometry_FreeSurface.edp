// OUTILS ET MACROS POUR LA GEOMETRIE DE LA SURFACE LIBRE
//
// script a inclure dans le code principal juste apres une declaration des maillages : 
//
//	th = maillage principal (utilise pour les integrales en volume) 
// 	(axe en x=r=0, label 1)
// 	(surface libre label 2)
// 	(parois solides label 5 et 6)
//	(reserver le label 3 pour un plan de symetrie)
// 
//      thsurface = maillage usilise pour toutes les inconnues en surface
//	NB selon les cas thsurface=th ou thsurface = emptymesh(th)
//
// Attention : ne pas mettre de commentaires au milieu des macros !


// FOR GOOD OPERATION THESE MACROS REQUIRE THE FOLLOWING VARIABLES :
//string surfaceorder /// possibilities : "direct", "reverse" (use reverse to fit with matlab "meniscus" program);
//string typestart // possibilites : "pined", "axis", "plane", "angle", "angleH"
//string typeend // possibilites : "pined", "axis", "plane", "angle"
//int anglecut // position of the "cut" in the tan2 determination. 
// anglecut = 0 => alpha in [-pi,pi]		=> suited for rotating polygon 
// anglecut = 1 => alpha in [-pi/2,3pi/2] 	=> suited for sessile drop,liquid bridge  
// anglecut = 2 => alpha in [0,2pi]			=> suited for vessel
// anglecut = 3 => alpta in [-3pi/2,pi/2] 	=> suited for hanging drop (?)



////////////////////////////////////////////////////////////////
//
// CHAPITRE 0 : DECLARATIONS
//
////////////////////////////////////////////////////////////////

int labelsurf = 2; // this will be changed to 8 very soon
int labelaxis = 1; // this will be changed to 6 very soon
int labelwall = 5; // this will be changed to 2 very soon

fespace Wh1(thsurface,P1);
Wh1 N0r,N0z,T0r,T0z,K0a,K0b,test,NormN;
fespace Vh(th,P1);

fespace femPP1(thsurface,P1); // maybe useless ?
int nbboundaryelements = thsurface.nbe;
int[int]  IndexPointSurf(nbboundaryelements+1); // Index du sommet dans la numrotation gnrale  
real[int] xPointSurf(nbboundaryelements+1); 
real[int] yPointSurf(nbboundaryelements+1);
real[int] S0PointSurf(nbboundaryelements+1);
// for new method
real[int] dS0PointSurf(nbboundaryelements+1);
real[int] alphaPointSurf(nbboundaryelements+1);
real[int] K0aPointSurf(nbboundaryelements+1);
real[int] K0bPointSurf(nbboundaryelements+1);
int Nsurface;
real[int] alphaSegSurf(nbboundaryelements);
////////////////////////////////////////////////////////////////
//
// CHAPITRE 1 : OUTILS POUR CALCULER LES NORMALES ET COURBURES
//
////////////////////////////////////////////////////////////////


// Methode 1 : ds deduit du vecteur normal (N.X,N.y) implemente dans FreeFe
macro Ds(u1)
(-dx(u1)*N.y+dy(u1)*N.x)
//EOM

// Methode 2 : a partir du T calcule par les macros
// Macros : derivees curvilignes le long de la surface pour un scalaire et un vecteur
//macro Ds(u1)
//(dx(u1)*T0r+dy(u1)*T0z)/*(-dx(u1)*N.y+dy(u1)*N.x)*/
//end of macro



macro Ds2(u1,u2)
[dx(u1)*T0r+dy(u1)*T0z,dx(u2)*T0r+dy(u2)*T0z]'*[T0r,T0z]
// 

macro Dn(u1)
(dx(u1)*N0r+dy(u1)*N0z)
//



// Definitions des problemes pour calcul normale, courbure
problem CalcN0r(N0r,test)=
  int1d(thsurface,labelsurf,qfe=qf3pE)(N0r*test*x)
  -int1d(thsurface,labelsurf,qfe=qf3pE)(N.x*test*x)
  +int2d(thsurface)((dx(N0r)*dx(test)+dy(N0r)*dy(test))*1e-8*x);
  


problem CalcN0z(N0z,test)=
  int1d(thsurface,labelsurf,qfe=qf3pE)(N0z*test)
  -int1d(thsurface,labelsurf,qfe=qf3pE)(N.y*test)
  +int2d(thsurface)((dx(N0z)*dx(test)+dy(N0z)*dy(test))*1e-30);
 



 
// Courbure : composante dans le plan medidien K0a et dans le plan perpendiculaire K0b 
//problem CalcK0a(K0a,test)=
//   int1d(thsurface,2,qfe=qf3pE)(K0a*test)
// + int2d(thsurface)(1e-10*K0a*test)
// - int1d(thsurface,2,qfe=qf3pE)(Ds2(N0r,N0z)*test);

problem CalcK0a(K0a,test)=
   int1d(thsurface,labelsurf,qfe=qf3pE)(K0a*test)
   +int2d(thsurface)((dx(K0a)*dx(test)+dy(K0a)*dy(test))*1e-30)
 - int1d(thsurface,labelsurf,qfe=qf3pE)(Ds2(N0r,N0z)*test)
 ;


/// Modif avec laplacien


problem CalcK0b(K0b,test)=
   int1d(thsurface,labelsurf,qfe=qf3pE)(K0b*test)
  +int2d(thsurface)((dx(K0b)*dx(test)+dy(K0b)*dy(test))*1e-30)
 - int1d(thsurface,labelsurf,qfe=qf3pE)(N0r/x*test);








// MACRO GLOBALE : ANCIENNE METHODE (la nouvelle est reportee au bout)
macro CalcGeomSurfANS
CalcN0r;
CalcN0z;
plot(N0r,wait=0,value=1);
plot(N0z,wait=0,value=1);
NormN = sqrt(N0r^2+N0z^2)+1e-10;
N0r = N0r/NormN;
N0z = N0z/NormN;
T0r = N0z;
T0z = -N0r;
CalcK0a;
CalcK0b;
plot(K0a,wait=0,value=1);
plot(K0b,wait=0,value=1);
cout << "max K0a : " << K0a[].max << " " << K0a[].min <<endl; 
//EOM
//


////////////////////////////////////////////////////////////////
//
// CHAPITRE 2 : OUTILS POUR DEFORMATION DE MAILLAGE (Newton)
//
////////////////////////////////////////////////////////////////



// Prolongement de la courbure dans le plan (pour la visualisation uniquement)
Vh K0ext,dK0ext;
problem ExtendC(K0ext,dK0ext)=
    int2d(th)((dx(K0ext)*dx(dK0ext)+dy(K0ext)*dy(dK0ext))*1e-40)
+on(labelsurf,K0ext=(K0a+K0b))
//+on(1,5,6,K0ext=K0)
;

// Calcul de la deformation de surface libre necessaire pour corriger la courbure du maillage (a pression imposee)
Wh1 etaNewton ;
problem CalcEta(etaNewton,test) 
	= int1d(thsurface,labelsurf)((gamma*(K0a+K0b)-(PP0-dpdz*y))*test*abs(x)) /* 1ere integrale : RHS */ 
        + int1d(thsurface,labelsurf)((gamma*(Ds(etaNewton))*(Ds(test))  -gamma*(K0a^2+K0b^2)*etaNewton*test +dpdz*etaNewton*test*N0z)*abs(x)) /* 2e integrale : matrice A */
        + int2d(thsurface)(1e-20*etaNewton*test) /* desingularisation */
        //+ on(1,5,55,6,etaNewton=0);
	+ int1d(thsurface,labelwall,55)(etaNewton*test*1e30*(typestart=="pined"))
	+ int1d(thsurface,labelaxis)(etaNewton*test*1e30)
	+ int1d(thsurface,labelwall)(etaNewton*test*1e30*(typestart=="angle"));		    

		    
		    
// Calcul de la deformation de surface libre necessaire pour corriger la courbure du maillage (a volume impose)	
// A REVOIR	   
macro CalcEtaV(etaNewton,PP1,V)
{
varf MatEta(etaNewton,test) = 
    int1d(thsurface,labelsurf)((gamma*(Ds(etaNewton))*(Ds(test))  -gamma*(K0a^2+K0b^2)*etaNewton*test+dpdz*etaNewton*test*N0z)*abs(x))
  + int2d(thsurface)(1e-20*etaNewton*test)
  + int1d(thsurface,labelwall,55)(etaNewton*test*1e30*(typestart=="pined"))
  + int1d(thsurface,labelaxis)(etaNewton*test*1e30)
  + int1d(thsurface,labelwall)(etaNewton*test*1e30*(typestart=="angle"));		 
varf MatEtaRHS(etaNewton,test) = 
	int1d(thsurface,labelsurf)(-(gamma*(K0a+K0b)-(PP0-dpdz*y))*test*abs(x));		    
varf VecEta(etaNewton,test) = int1d(thsurface,labelsurf)(-test*abs(x));
varf VecVol(etaNewton,test) = int1d(thsurface,labelsurf)(test*abs(x));
matrix A11 = MatEta(Wh1,Wh1); 
real[int] A12 = VecEta(0,Wh1); 
real[int] A21p = VecVol(0,Wh1); 
real A22 = 0;
matrix A = [[A11, A12],[A21p',A22]];
set(A,solver=sparsesolver);
real[int] RHS1 = MatEtaRHS(0,Wh1);
real RHS2 = V-int2d(th)(x); 
real[int] RHS = [RHS1,RHS2];
real[int] xx = A^-1 * RHS;
etaNewton = etaNewton;
[etaNewton[],PP1] = xx;
}
//EOM


		    
		    
		     
// Prolongement de la deformation dans le domaine (pour visualisation uniquement)
Vh etaext;
problem ExtendEta(etaext,dK0ext) =
    int2d(th)((dx(etaext)*dx(dK0ext)+dy(etaext)*dy(dK0ext)))
+on(labelsurf,etaext=etaNewton);

// Calcul du champ lagrangien pour deformation de maillage
fespace Vh11(th,[P1,P1]);
Vh11 [uz,ur], [vz,vr];

// problem pour cas pined
problem CalcDef([uz,ur],[vz,vr])=
    int2d(th)( ((dx(uz)*dx(vz)+dy(uz)*dy(vz)) + (dx(ur)*dx(vr)+dy(ur)*dy(vr))) )
+on(labelsurf,ur=etaNewton*N0r,uz=etaNewton*N0z)
+int1d(th,labelwall,55)((ur*vr*1e30+uz*vz*1e30)*(typestart=="pined"))
+int1d(th,labelaxis,11)((ur*vr)*1e30);
//+on(5,6,55,ur=0,uz=0)
//+on(1,11,ur=0,uz=0); // ne pas le faire sur l'axe


// problem pour cas angle
problem CalcDefAngle([uz,ur],[vz,vr])=
    int2d(th)( ((dx(uz)*dx(vz)+dy(uz)*dy(vz)) + (dx(ur)*dx(vr)+dy(ur)*dy(vr))) )
+on(labelsurf,ur=etaNewton*N0r,uz=etaNewton*N0z-etaNewton[](IndexPointSurf(0))*cos(alphaPointSurf(0)) )
+on(labelwall,6,55,uz=0)//enlever 55 pour la cas pined
+on(labelaxis,11,ur=0); // ne pas le faire sur l'axe

// problem pour liquid bridge
problem CalcDefBridge([uz,ur],[vz,vr])=
    int2d(th)( (dx(uz)*dx(vz)+dy(uz)*dy(vz)) + (dx(ur)*dx(vr)+dy(ur)*dy(vr)) )
+on(labelsurf,ur=etaNewton*N0r,uz=etaNewton*N0z)
+on(labelaxis,labelwall,6,ur=0,uz=0);






////////////////////////////////////////////////////////////////
//
// CHAPITRE 3 : OUTILS POUR EXTRACTION DE VALEURS LE LONG DE LA SURFACE
//
////////////////////////////////////////////////////////////////




macro SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface)
{
int ksurf = 0;
for(int k=0;k<nbboundaryelements;k++) 
{
	if(thsurface.be(k).label==labelsurf) 
	{
	if (ksurf==0){IndexPointSurf(ksurf) = thsurface.be(k)[0];}
	else{if(IndexPointSurf(ksurf) !=thsurface.be(k)[0]){cout << "WARNING probleme numeration de la surface !" << endl ; ksurf = -1;break;}}
	IndexPointSurf(ksurf+1) = thsurface.be(k)[1];	
	ksurf++;
	};
};
if(ksurf>0)
{cout << "Macro SurfaceNumbering : Successful numbering of free surface, direct order ; Nsurf = " << ksurf << endl;}
else
{
ksurf = 0;
for(int k=nbboundaryelements-1;k>-1;k--)
{
	if(thsurface.be(k).label==2) 
	{
	if (ksurf==0){IndexPointSurf(ksurf) = thsurface.be(k)[1];};
	/*else{if(IndexPointSurf(ksurf) !=thsurface.be(k)[1]){cout << "toto" ;};};*/
	IndexPointSurf(ksurf+1) = thsurface.be(k)[0];	
	ksurf++;
	};
};
cout << "Macro SurfaceNumbering : Successful numbering of free surface, reverse order ; Nsurf = " << ksurf << endl;
};
Nsurface = ksurf; 
for(ksurf=0;ksurf<Nsurface+1;ksurf++)
       {
	xPointSurf(ksurf) = thsurface(IndexPointSurf(ksurf)).x;
	yPointSurf(ksurf) = thsurface(IndexPointSurf(ksurf)).y;
	if(ksurf>0)
		{ S0PointSurf(ksurf) = S0PointSurf(ksurf-1)+ sqrt((xPointSurf(ksurf-1)-xPointSurf(ksurf))^2+(yPointSurf(ksurf-1)-yPointSurf(ksurf))^2);
		  dS0PointSurf(ksurf-1) = sqrt((xPointSurf(ksurf-1)-xPointSurf(ksurf))^2+(yPointSurf(ksurf-1)-yPointSurf(ksurf))^2);	
	         }
	 else{S0PointSurf(0)=0;};
         }

for(int ksurf=0;ksurf<Nsurface;ksurf++)
	{
		if(anglecut==0)
		{   alphaSegSurf(ksurf) = atan2(yPointSurf(ksurf+1)-yPointSurf(ksurf),xPointSurf(ksurf+1)-xPointSurf(ksurf));   }
		else if(anglecut==1)
		{   alphaSegSurf(ksurf) = pi/2-atan2(xPointSurf(ksurf+1)-xPointSurf(ksurf),yPointSurf(ksurf+1)-yPointSurf(ksurf));   } 
		else if(anglecut==2)
		{   alphaSegSurf(ksurf) = pi+atan2(-(yPointSurf(ksurf+1)-yPointSurf(ksurf)),-(xPointSurf(ksurf+1)-xPointSurf(ksurf))); }
		else if(anglecut==3)
		{	alphaSegSurf(ksurf) = -pi/2-atan2(-(xPointSurf(ksurf+1)-xPointSurf(ksurf)),-(yPointSurf(ksurf+1)-yPointSurf(ksurf)));   };
	};
for(ksurf=1;ksurf<Nsurface;ksurf++)
	  {
	  alphaPointSurf(ksurf) = (dS0PointSurf(ksurf)*alphaSegSurf(ksurf-1)+dS0PointSurf(ksurf-1)*alphaSegSurf(ksurf))/(dS0PointSurf(ksurf-1)+dS0PointSurf(ksurf));
	  K0aPointSurf(ksurf) =(alphaSegSurf(ksurf)-alphaSegSurf(ksurf-1))/((dS0PointSurf(ksurf)+dS0PointSurf(ksurf-1))/2);;
	  K0bPointSurf(ksurf) = sin(alphaPointSurf(ksurf))/xPointSurf(ksurf);
	  }                 

/* cas des points extremes : a rationaliser */
          if(typestart=="pined")
	  {
		real alphaA=alphaSegSurf(0);
		real alphaB=alphaSegSurf(1);
		real alphaC=alphaSegSurf(2);
		real sA= dS0PointSurf(0)/2;
		real sB= dS0PointSurf(0)+dS0PointSurf(1)/2.;
		real sC= dS0PointSurf(0)+dS0PointSurf(1)+dS0PointSurf(2)/2.;
		alphaPointSurf(0)=(alphaA*sB*sB*sC-alphaA*sB*sC*sC-alphaB*sA*sA*sC+alphaB*sA*sC*sC+alphaC*sA*sA*sB-alphaC*sA*sB*sB)/(sA-sB)/(sA*sB-sA*sC-sB*sC+sC*sC);
		K0aPointSurf(0)=-(alphaA*sB*sB-sC*sC*alphaA-sA*sA*alphaB+sC*sC*alphaB+sA*sA*alphaC-alphaC*sB*sB)/(sA-sB)/(sA*sB-sA*sC-sB*sC+sC*sC);
	        K0bPointSurf(0)=sin(alphaPointSurf(0))/xPointSurf(0);
          }
 	else if(typestart=="angle")
	  {  real alphaA=alphaSegSurf(0);
		real alphaB=alphaSegSurf(1);
		real alphaC=alphaSegSurf(2);
		real sA= dS0PointSurf(0)/2;
		real sB= dS0PointSurf(0)+dS0PointSurf(1)/2.;
		real sC= dS0PointSurf(0)+dS0PointSurf(1)+dS0PointSurf(2)/2.;
		alphaPointSurf(0)=(alphaA*sB*sB*sC-alphaA*sB*sC*sC-alphaB*sA*sA*sC+alphaB*sA*sC*sC+alphaC*sA*sA*sB-alphaC*sA*sB*sB)/(sA-sB)/(sA*sB-sA*sC-sB*sC+sC*sC);
		K0aPointSurf(0)=K0aPointSurf(0)=-(alphaA*sB*sB-sC*sC*alphaA-sA*sA*alphaB+sC*sC*alphaB+sA*sA*alphaC-alphaC*sB*sB)/(sA-sB)/(sA*sB-sA*sC-sB*sC+sC*sC);
	        K0bPointSurf(0)=sin(alphaPointSurf(0))/xPointSurf(0);
          }
          else if(typestart=="axis")
          { 
          alphaPointSurf(0) = 0;
          K0aPointSurf(0)=2/dS0PointSurf(0)*alphaSegSurf(0);
	      K0bPointSurf(0)=2/dS0PointSurf(0)*alphaSegSurf(0);
          };

          if(typeend=="pined")
	  { 
	  alphaPointSurf(Nsurface)=2*alphaPointSurf(Nsurface-1)-alphaPointSurf(Nsurface-2);
	  K0aPointSurf(Nsurface)=2*K0aPointSurf(Nsurface-1)-K0aPointSurf(Nsurface-2);
	  K0bPointSurf(Nsurface)=2*K0bPointSurf(Nsurface-1)-K0bPointSurf(Nsurface-2);
          }
          else if(typeend=="axis")
          { 
          alphaPointSurf(Nsurface) =2*alphaPointSurf(Nsurface-1)-alphaPointSurf(Nsurface-2);
          K0bPointSurf(Nsurface)=-2*sin(alphaSegSurf(Nsurface-1))/dS0PointSurf(Nsurface-1);
	  K0aPointSurf(Nsurface)=K0bPointSurf(Nsurface);
          };

}
//EOM


// MACRO GLOBALE : NOUVELLE METHODE
macro CalcGeomSurf
SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface);
	K0a = 0*K0a;
	K0b = 0*K0b;
	N0r = 0*N0r;
	N0z = 0*N0z;
for(int ksurf=0;ksurf<Nsurface+1;ksurf++)
{
	
K0a[][IndexPointSurf(ksurf)  ] = K0aPointSurf(ksurf);
K0b[][IndexPointSurf(ksurf)  ] = K0bPointSurf(ksurf);
T0r[][IndexPointSurf(ksurf)  ] = cos(alphaPointSurf(ksurf));
T0z[][IndexPointSurf(ksurf)  ] = sin(alphaPointSurf(ksurf));

N0r[][IndexPointSurf(ksurf)  ] = sin(alphaPointSurf(ksurf));
N0z[][IndexPointSurf(ksurf)  ] = -cos(alphaPointSurf(ksurf));
}
IFMACRO(FREEFEMPLOTS,YES)
plot([N0r,N0z],wait=0,value=1,cmm=" CalcGeom : Normale");
plot(thsurface,K0a,wait=0,value=1,cmm="CalcGeom : K0a");
plot(K0b,wait=0,value=1,cmm="CalcGeom : K0b");
ENDIFMACRO
//EOM

