//
//  PROGRAM Adapt_UVWP.edp
//  adaptmesh for axisymmetric base flow
//   
//
//  INPUT PARAMETERS (from pipe) :
//   	Eigenmode.txt One file containing [P2,P2,P2,P1] field)
// 			syntax : FreeFem++ Adapt_UVWP.edp < Eigenmode.txt
//	INPUT FILES :
// 		mesh.msh 			->  mesh in Freefem format
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
//  OUTPUT FILES :
//		BaseFlow_guess.txt			
//		mesh.msh 
//		Eigenmode_guess.txt -> may be useful to provide initial guess for Shift/invert solver
// 		nb : BaseFlow.txt and Eigenmode_guess.txt are destroyed, to avoid wrong usage	
//      ( copies mesh_guess.msh mesh.msh BaseFlow_guess.txt ; are they still useful ?)
// 	ERROR MANAGEMENT : 
//
//  D. Fabre et al., June 2017




	verbosity = 0;
	string AAA = "FreeFem++";

// NB in this development version Hmax is read in a Param file written by the driver !

	real Nbvx	= 50000.;		//maximun number of vertices
//	real Hmin	= .5e-4;           	//minimun edge size 
//	real Hmax	= .5;			//maximun edge size  	
//	real Ratio	= 10.;               	//ratio for the smoothing of the mesh
	real Thetamax	= 1e-3;			//minimum corner angle in degree
	real Verbosity	= 1; // warning : must be integer !
	bool Splitpbedge= false;
//	real error	= 1e-2;			//interpolation error level, it decreases on each iteration
//	real rr         = 0.95;              	//ratio of the geometric sequence of the error	
//	bool Splitin2 = false;
	

include "Param_Adaptmesh.edp";


	mesh th=readmesh("mesh.msh");
	int nvprev = th.nv;
	    fespace femp2(th,P2);   
        fespace femp1(th,P1);
        fespace femp0(th,P0);
        fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
        fespace femp2xfemp2xfemp2xfemp1(th,[P2,P2,P2,P1]);
        femp2xfemp2xfemp1 [vB,uB,pB]; // base flow
        femp2xfemp2xfemp2xfemp1<complex> [vC,uC,wC,pC];	// structure of forced problem (complex)
        femp2xfemp2xfemp2xfemp1 [v,u,w,p], [vi,ui,wi,pii],[vBR,uBR,wBR,pBR];	// real and imaginary parts
	
	cout << "###################################" << endl;
cout << endl << "       Adapt_UVWP.edp        " << endl; 
cout << endl << "###################################" << endl << endl;

	
	
	real Re;
	
	{
	ifstream U("BaseFlow_ans.txt");		
	U >> vB[];
	U >> Re;
	}
    cout << " lecture of Base flow : Reynolds number = " << Re << endl;


cin >> uC[];
cin >> Re;

//[v,u,p] = [real(vC)/abs(vC)*exp(-y^2),real(uC)/abs(uC)*exp(-y^2),real(pC)/abs(pC)*exp(-y^2)];
//[v,u,p] = [real(pC)/abs(pC)*exp(-y^2),real(pC)/abs(pC)*exp(-y^2),real(pC)/abs(pC)*exp(-y^2)];
//[v,u,p] = [real(vC)*exp(-y^2),real(uC)*exp(-y^2),real(pC)/abs(pC)*exp(-y^2)];

[v,u,w,p] = [real(vC),real(uC),real(wC),real(pC)];
[vi,ui,wi,pii] = [imag(vC),imag(uC),imag(wC),imag(pC)];
[vBR,uBR,wbR,pBR] = [vB,uB,0,pB]; // interpolation of base flow


cout << " lecture of field [V,U,P] from standart input for RE = " << Re;
if(ui[].max<1e-6){ cout << " (Real field ; most likely a base flow) " << endl;}
else{  cout << " (complex field ; most likely response to a forcing) "<< endl; };


//cout << "SINGLE MESH ADAPTATION ; " << endl; 

//cout << " Reynolds number = " << Re << endl;


cout << endl << "#### Mesh information BEFORE ADAPT :" << endl;  
        cout << "#### Number of vertices    " << th.nv <<  endl;
	    cout << "### Dimension of matrices " << v[].n << endl << endl;


	
	

///////////////////////////////////////////////////////////////////////////////////////////////////
// Calcul des champs de base //////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

/*
	string date;
	{date=exec("date +%d/%m-%H:%M");}                 
	
	{ofstream log("log.txt",append);	//output log file, usefull if you want to  			
	log << endl << endl;			//check adaptMesh's settings
	log <<  "/////////////////////////////////////////////////////////" <<endl;
	log <<  "/////////////////////New calculation/////////////////////" <<endl;		
	log <<  "/////////////////////////////////////////////////////////" <<endl;	
	log <<  "// Date                = "<< date                          <<endl;
	log <<  "// Nbvx                = "<< Nbvx                          <<endl;		
	log <<	"// Hmin                = "<< Hmin                          <<endl;   	
	log <<	"// Hmax                = "<< Hmax                          <<endl;	
	log <<	"// Ratio               = "<< Ratio                         <<endl;         	
	log <<	"// Thetamax            = "<< Thetamax                      <<endl;		
	log <<	"// Verbosity           = "<< Verbosity                     <<endl;
	log <<	"// Splitpbedge         = "<< Splitpbedge                   <<endl;
	log <<	"// error               = "<< error                         <<endl;	
	log <<	"// error ratio         = "<< rr                            <<endl;	
	log <<  "/////////////////////////////////////////////////////////" <<endl<<endl;}
*/		
	
real Lcut=2;	
			cout << " dim of u[] before adapt : " << u[].n <<  endl;
			
			mesh thold = th;
			mesh thnew;				
thnew = adaptmesh(th,[v,u,w,p],[vi,ui,wi,pii],[vBR,uBR,wBR,pBR],
nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,verbosity=Verbosity,splitpbedge=Splitpbedge);
			
			cout << endl << "...............New mesh created..............." << endl << endl;




   fespace femp2N(thnew,P2);   
        fespace femp1N(thnew,P1);
        fespace femp0N(thnew,P0);
        fespace femp2xfemp2xfemp2xfemp1N(thnew,[P2,P2,P2,P1]);
        fespace femp2xfemp2xfemp1N(thnew,[P2,P2,P1]);
        femp2xfemp2xfemp2xfemp1N [vN,uN,wN,pN];
        femp2xfemp2xfemp1N [vBN,uBN,pBN];
        [vN,uN,wN,pN] = [v,u,w,p]; // interpolation of structure
       	[vBN,uBN,pBN] = [vB,uB,pB]; // interpolation of base flow

cout << endl << "#### Mesh information AFTER ADAPT :" << endl;  
        cout << "#### Number of vertices    " << thnew.nv <<  endl;
	    cout << "### Dimension of matrices " << vN[].n << endl << endl;
					









	cout << "     copying  interpolated base flow to files BaseFlow_adapt.txt and BaseFlow_guess.txt " 
	     << endl;
	     
	   
			

	savemesh(thnew,"mesh_adapt.msh");

 
real[int] xprobe = [0,	2.5,	4,	10];
    	real[int] yprobe = [.5, 	.5,	0,	0];
     	 
     	 {
     	 cout << "Writing mesh_adapt.ff2m" << endl;
 		 ofstream fileFF("mesh_adapt.ff2m");
 		 fileFF << "### MESH generated by Freefem++ ; " << endl;
    	 fileFF << "2D" << endl;
    	 fileFF << "Format :" << endl;
	     fileFF << "int np int Ndof real deltamin real deltamax real deltaA real deltaB real deltaC real deltaD int AdaptGeneration" 
	     << endl << endl ; 
		 fileFF << thnew.nv <<  endl << vBN[].n << endl ;
		 fileFF << delta[].min << endl;
		 fileFF << delta[].max << endl;
		 for(int ii = 0; ii<4;ii++)
		 	{ fileFF << delta(xprobe(ii),yprobe(ii)) << endl ;}
    	 fileFF << 1 << endl;	
 		 };





	

	
cout << "...............New mesh  saved..............." << endl;

	     
		{
		ofstream U("BaseFlow_guess.txt");		
        U << vBN[];
        U << endl << endl <<  Re << endl;
	  	}
	  	
	  	{
		ofstream U("Eigenmode_guess.txt");		
        U << vN[];
        U << endl << endl <<  Re << endl;
	  	}


 //        exec("cp BaseFlow_adaptCOMPLEX.txt BaseFlow_guessCOMPLEX.txt");			
//	 exec("cp mesh_adapt.msh mesh_guess.msh");

	 exec("cp mesh_adapt.msh mesh.msh");
	 exec("rm BaseFlow.txt Eigenmode_guess.txt");  

			plot(thold,wait=1);
			plot(thnew,wait=1);

			plot(uBN,fill=1,wait=1);
			plot(vBN,fill=1,wait=1);
			plot(pBN,fill=1,wait=1);

			plot(uN,fill=1,wait=1);
			plot(vN,fill=1,wait=1);
			plot(pN,fill=1,wait=1);



