//
//  PROGRAM Adapt_Axi.edp
//  adaptmesh for axisymmetric base flow
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	none
//	INPUT FILES :
// 		mesh_ans.msh 			->  mesh in Freefem format
//		chbase.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
//  OUTPUT FILES :
//		chbase_adaptguess.txt			
//		mesh_adapt.msh 
// 		nb : chbase.txt and Eigenmode_guess.txt are destroyed, to avoid wrong usage		
// 	ERROR MANAGEMENT : 
//
//  D. Fabre et al., June 2017


	verbosity = 0;
	string AAA = "FreeFem++";

 	exec("rm chbase.txt Eigenmode_guess.txt"); 

	mesh th=readmesh("mesh_ans.msh");
	int nvprev = th.nv;
	    fespace femp2(th,P2);   
        fespace femp1(th,P1);
        fespace femp0(th,P0);
        fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
        femp2xfemp2xfemp1 [v,u,p];
	
	
	cout << "###################################" << endl;
cout << endl << "       Adapt_Axi.edp        " << endl; 
cout << endl << "###################################" << endl << endl;

	
	
	real Re;
	
	{
	ifstream U("chbase_ans.txt");		
	U >> v[];
	U >> Re;
	}

//cout << "SINGLE MESH ADAPTATION ; " << endl; 

cout << " Reynolds number = " << Re << endl;


cout << endl << "#### Mesh information BEFORE ADAPT :" << endl;  
        cout << "#### Number of vertices    " << th.nv <<  endl;
	    cout << "### Dimension of matrices " << v[].n << endl << endl;


	
	

///////////////////////////////////////////////////////////////////////////////////////////////////
// Calcul des champs de base //////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

	////////////////////////////////////
	//  Parameters for the adaptMesh  //
	////////////////////////////////////

// NB in this development version Hmax is read in a Param file written by the driver !

	real Nbvx	= 50000.;		//maximun number of vertices
	real Hmin	= .5e-4;           	//minimun edge size 
//	real Hmax	= 5;			//maximun edge size  	
	real Ratio	= 10.;               	//ratio for the smoothing of the mesh
	real Thetamax	= 1e-3;			//minimum corner angle in degree
	real Verbosity	= 1; // warning : must be integer !
	bool Splitpbedge= false;
	real error	= 1e-2;			//interpolation error level, it decreases on each iteration
	real rr         = 0.95;              	//ratio of the geometric sequence of the error

include "Param_Adaptmesh.edp";

/*
	string date;
	{date=exec("date +%d/%m-%H:%M");}                 
	
	{ofstream log("log.txt",append);	//output log file, usefull if you want to  			
	log << endl << endl;			//check adaptMesh's settings
	log <<  "/////////////////////////////////////////////////////////" <<endl;
	log <<  "/////////////////////New calculation/////////////////////" <<endl;		
	log <<  "/////////////////////////////////////////////////////////" <<endl;	
	log <<  "// Date                = "<< date                          <<endl;
	log <<  "// Nbvx                = "<< Nbvx                          <<endl;		
	log <<	"// Hmin                = "<< Hmin                          <<endl;   	
	log <<	"// Hmax                = "<< Hmax                          <<endl;	
	log <<	"// Ratio               = "<< Ratio                         <<endl;         	
	log <<	"// Thetamax            = "<< Thetamax                      <<endl;		
	log <<	"// Verbosity           = "<< Verbosity                     <<endl;
	log <<	"// Splitpbedge         = "<< Splitpbedge                   <<endl;
	log <<	"// error               = "<< error                         <<endl;	
	log <<	"// error ratio         = "<< rr                            <<endl;	
	log <<  "/////////////////////////////////////////////////////////" <<endl<<endl;}
*/		
	
	
			cout << " dim of u[] before adapt : " << u[].n <<  endl;
			
			mesh thold = th;
			mesh thnew;				
			thnew = adaptmesh(	th,[v,u,p],nbvx=Nbvx,err=error,ratio=Ratio,
					hmax=Hmax,hmin=Hmin,thetamax=Thetamax,verbosity=Verbosity,splitpbedge=Splitpbedge);
			
			cout << endl << "...............New mesh created..............." << endl << endl;


 


		plot(thnew,wait=1);
			
	    fespace femp2N(thnew,P2);   
        fespace femp1N(thnew,P1);
        fespace femp0N(thnew,P0);
        fespace femp2xfemp2xfemp1N(thnew,[P2,P2,P1]);
        femp2xfemp2xfemp1N [vN,uN,pN];
		[vN,uN,pN] = [v,u,p];



cout << endl << "#### Mesh information AFTER ADAPT :" << endl;  
        cout << "#### Number of vertices    " << thnew.nv <<  endl;
	    cout << "### Dimension of matrices " << vN[].n << endl << endl;
					
//			plot(thold,th,wait=1);
			plot(uN,fill=1,wait=1);
			plot(vN,fill=1,wait=1);
			plot(pN,fill=1,wait=1);


savemesh(thnew,"mesh_adapt.msh");
    {
	ofstream U("chbase_adaptguess.txt");		
	U << vN[];
	U << endl << endl <<  Re << endl;
	}
//exec("cp mesh_adapt.msh mesh_guess.msh");
//exec("cp mesh_adapt.msh mesh.msh");
//exec("cp chbase_adapt.txt chbase_guess.txt");
exec("rm chbase.txt");  


//exec("rm Eigenmode_guess.txt"); -> do that in driver


//			exec("mv cbn_Re"+Re+".* save/");	
//			exec("rm meshallnew.msh");
		//	plot(th,wait=0);			// --> May cause broken pipe error.
			
			
			cout << "...............New mesh and base flow saved..............." << endl;

//			error = error * rr;			//interpolation error level, it decreases on each iteration

/*			
			///////////////////////////////////////////////////////////////////////////
			/////  Creation of the matrix for the change of finite element base  ////// 	
			///////////////////////////////////////////////////////////////////////////

			mesh thold=readmesh("meshall.msh");			//old mesh
			fespace Vhold(thold,[P2,P2,P1]);			//old FE-space

			
			mesh thnew=readmesh("meshallnew.msh");			//new mesh
			fespace Vhnew(thnew,[P2,P2,P1]);			//new FE-space
			Vhnew [V,U,P];						//new base flow field

			
			int nbvold = thold.nv;
			int nbvnew = thnew.nv;

			
			cout << endl;
			cout << "Old mesh, Nmat = " << v[].n << "Nbvertices =" << nbvold << endl;
			cout << "New mesh, Nmat = " << V[].n << "Nbvertices =" << nbvnew << endl;	
			cout << "Error criteria for the adaptmesh calculation, err = " << error/rr << endl; 

			plot(th,U); 
			     {ofstream log("log.txt",append);
			     log << "Old mesh, Nmat =     " << v[].n << "     Nbvertices =     " << nbvold << endl;	
			     log << "New mesh, Nmat =     " << V[].n << "     Nbvertices =     " << nbvnew << endl;	
			     log << "Error criteria, err =     "<<error/rr<< endl<<endl;}	 

			matrix IV = interpolate(Vhnew,Vhold);			//matrix for the change of FE-space

			cout << "...............Matrix for the change of FE-space created..............." << endl;

			/////////////////////////////////////////////////////////////////////
			/////  Calculation of u,v,p in the new base of finite element  ////// 	
			/////////////////////////////////////////////////////////////////////

			V[] = IV*v[];				//calculation of the base flow field in the new FE-space 

			cout << "...............Base flow writen in the FE-space..............." << endl;

			exec("rm chbase_guess.txt chbase.txt");			//suppression of the base flow wroten 
										//for the old FE-space

			{
			ofstream file("chbase.txt");				//output of the new base flow field
			file << V[];
			file << endl << endl << Re << endl;
			}


			exec("cp chbase.txt chbase_guess.txt");
			exec("mv meshallnew.msh meshall.msh");
			cout << "...............AdaptMesh section ended..............." << endl;
		}

		else 	{
		//	exec("mv criteria.txt save/");  			// convergence criteria
			cout << endl << endl << endl;
			cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
			cout << "!!! Calculation of base flow ended !!!" << endl;
			cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl << endl << endl; 
			}
	
	}

exec("rm Re.txt");
*/

