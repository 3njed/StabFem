//
//  PROGRAM Adapt_UVP.edp
//  adaptmesh for 2D flow PLUS EIGENMODE
//   
// Usage : FreeFem++ Adapt_Mode.edp "type"
//
//  INPUT PARAMETERS (from pipe) : "type" where types are "ReP2P2P1 CxP2P2P1 ReP2P2P2P1 CxP2P2P2P1
//														   ReP2P2P1P1 CxP2P2P1P1 ReP2P2P1P1P1 CxP2P2P1P1P1" 
// 														 
//
//	INPUT FILES :
// 		mesh_toadapt.msh ->  mesh in Freefem format
//		Fieldi_toadapt.txt	-> Field in type[i] space
// 		Data in this file depends upon option "type"
//			type = "ReP2P2P1" -> Real P2xP2xP1 data (for instance 2D base flow)
//			type = "CxP2P2P1" -> Complex P2xP2xP1 data (for instance 2D mode or 2D base flow with complex mapping)
//			type = "ReP2P2P2P1" -> Real P2xP2xP2xP1 data (for instance 3D base flow)
//			type = "CxP2P2P2P1" -> Complex P2xP2xP2xP1 data (for instance 3D mode or 3D base flow with complex mapping)
//			type = "ReP2P2P1P1" -> Real P2xP2xP1xP1 data (for instance 2D base flow with extra scalar)
//			type = "CxP2P2P1P1" -> Complex P2xP2xP1xP1 data (for instance 2D mode or 2D base flow with complex mapping with an extra scalar)
//			type = "ReP2P2P1P1P1" -> Real P2xP2xP1xP1xP1 data (for instance 2D compressible base flow)
//			type = "CxP2P2P1P1P1" -> Complex P2xP2xP1xP1xP1 data (for instance 2D compressible mode or 2D compressible base flow with complex mapping)
//
//  OUTPUT FILES :
//		mesh_adapted.msh -> New mesh
//		Fieldi_adapted.txt -> Fieldi interpolated on new mesh (guess for next Newton)		
//		Fieldi_toadapt_ans.txt -> Previous Fieldi in the previous mesh in case adaptmesh was not successful
//		mesh_ans.msh -> previous mesh in case adaptmesh was not successful 
// 		nb : BaseFlow.txt is removed, to force new computation with Newton (If baseflow is selected)
// 	ERROR MANAGEMENT : 
//
//  J. Sierra , July 2018
//


	include "SF_Geom.edp"; 
	include "Macros_StabFem.edp";

	int nFields=3; // Number of fields considered for mesh adaptation
	string[int] type(nFields);

	// RUNTIME selection of the Fields
	for (int i=0;i<nFields;i++)
	{
		cout << "Select type of data for Field"<<i<<" ? [ReP2, CxP2, ReP2P2P1 CxP2P2P1 ReP2P2P2P1 CxP2P2P2P1 ReP2P2P1P1P1 CxP2P2P1P1P1 ReP2P2P1P1 CxP2P2P1P1] or None if you do not want Field" << i << endl;
		if(i==0)
			cout << "For Field0. Select a baseflow, a DNS snapshot, HB flow field or any other field containing the Reynolds number at the end of the file" << endl;
		cin >> type[i]; 
	}

	

	// Parameters for adaptmesh functionality
	real Nbvx	= 50000.;		//maximun number of vertices
	real Thetamax	= 1e-3;			//minimum corner angle in degree
	real Verbosity	= 1; // warning : must be integer !
	bool Splitpbedge= false;
//	real Hmin	= .1e-4;           	//minimun edge size 
//	real Hmax	= .5;			//maximun edge size  	
//	real Ratio	= 10.;               	//ratio for the smoothing of the mesh
//	real error	= 1e-2;			//interpolation error level, it decreases on each iteration
// 
// NB ALL THESE PARAMETERS ARE NOW WRITTEN IN THIS FILE :
	include "Param_Adaptmesh.edp";

<<<<<<< HEAD
	// Copy input files
	exec("cp "+ffdatadir+"mesh.msh "+ffdatadir+"mesh_ans.msh");
	exec("cp "+ffdatadir+"mesh.ff2m "+ffdatadir+"mesh_ans.ff2m");
	for (int i=0; i<nFields;++i)
	{
		exec("cp "+ffdatadir+"Field"+i+"_toadapt.txt "+ffdatadir+"Field"+i+"_toadapt_ans.txt ");
	}
=======

// THIS IS TO BE DONE IN THE DRIVER AND REMOVED FROM HERE ! 
	exec("cp "+ffdatadir+"mesh.msh "+ffdatadir+"mesh_ans.msh");
	exec("cp "+ffdatadir+"mesh.ff2m "+ffdatadir+"mesh_ans.ff2m");
	exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_ans.txt");
	exec("cp "+ffdatadir+"BaseFlow.ff2m "+ffdatadir+"BaseFlow_ans.ff2m");
//
>>>>>>> master

	// Read the old mesh	 
	mesh th=readmesh(ffdatadir+"mesh_toadapt.msh");
	mesh thold = th;
	int nvprev = th.nv;

	// Declaration of FEM spaces
	    
	fespace femp2(th,P2);   
    fespace femp1(th,P1);
    fespace femp0(th,P0);
    fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
    fespace femp2xfemp2xfemp1xfemp1(th,[P2,P2,P1,P1]);
    fespace femp2xfemp2xfemp2xfemp1(th,[P2,P2,P2,P1]);
	fespace femp2xfemp2xfemp1xfemp1xfemp1(th,[P2,P2,P1,P1,P1]); /// 

	// Declaration of generic fields

	macro defP2(Field)[Field#P2e1]//EOF
	macro defP2P2P1(Field)[Field#P2e1,Field#P2e2,Field#P1e1]//EOF
	macro defP2P2P2P1(Field)[Field#P2e1,Field#P2e2,Field#P2e3,Field#P1e1]//EOF
	macro defP2P2P1P1(Field)[Field#P2e1,Field#P2e2,Field#P1e1,Field#P1e2]//EOF
	macro defP2P2P1P1P1(Field)[Field#P2e1,Field#P2e2,Field#P1e1,Field#P1e2,Field#P1e3]//EOF

	// Definition of generic macros to be used in adaptmesh
	macro defField(Field,i)[Field#P2e1[i],Field#P2e2[i],Field#P1e1[i],Field#P1e2[i]] //
	macro definitionField(Field)[Field#P2e1,Field#P2e2,Field#P1e1,Field#P1e2] //

	// Generic definition of adaptmesh fields
	femp2xfemp2xfemp1xfemp1[int] definitionField(FieldRe)(nFields);
	femp2xfemp2xfemp1xfemp1[int] definitionField(FieldImag)(nFields);

<<<<<<< HEAD
	femp2 defP2(ReP2Field); // Real P2P2P1 Field
    femp2 <complex> defP2(CxP2Field); // Complex P2P2P1 Field
=======
	else if(type=="Comp")
	{
		cout << " ADAPTATION TO FIELD WITH UVPTRho STRUCTURE" << endl;	
		ifstream fileAdaptField(ffdatadir+"AdaptField.txt");
    		femp2xfemp2xfemp2xfemp1 [uc1,vc1,pc1,Tc1], [uc2,vc2,pc2,Tc2];	// real and imaginary parts
		fileAdaptField >> uc[];
		[uc1,vc1,pc1,Tc1] = [real(uc),real(vc),real(pc),real(Tc)];
		[uc2,vc2,pc2,Tc2] = [imag(uc),imag(vc),imag(pc),imag(Tc)];
		[uComp,vComp,pComp,TComp] = [uBc,vBc,pBc,TBc];
		cout << " lecture of field with structure [U,V,P,T,RHO]" << endl;
		if(uc2[].max<1e-6){ cout << " (Real field ; most likely a base flow) " << endl;}
		else{  cout << " (complex field ; most likely an eigenmode or response to a forcing) "<< endl; };
			
		thnew = adaptmesh(th,[uc1,vc1,pc1,Tc1],[uc2,vc2,pc2,Tc2],[uBc,vBc,pBc,TBc],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);		
	}
	
	else if(type=="UVWP")
	{
		cout << " ADAPTATION TO FIELD WITH UVWP STRUCTURE" << endl;	
		ifstream fileAdaptField(ffdatadir+"AdaptField.txt");
    	femp2xfemp2xfemp2xfemp1 [u,v,w,p], [ui,vi,wi,pii];	// real and imaginary parts
		fileAdaptField >> uCC[];
		[u,v,w,p] = [real(uCC),real(vCC),real(wCC),real(pCC)];
		[ui,vi,wi,pii] = [imag(uCC),imag(vCC),imag(wCC),imag(pCC)];
		
		cout << " lecture of field with structure [U,V,W,P]" << endl;
		if(ui[].max<1e-6){ cout << " (Real field ; most likely a base flow) " << endl;}
		else{  cout << " (complex field ; most likely an eigenmode or response to a forcing) "<< endl; };
			
		thnew = adaptmesh(th,[u,v,w,p],[ui,vi,wi,pii],[vBS,uBS,wBS,pBS],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);		
	}
	
	else if(type=="Sensitivity")
	{
		cout << " ADAPTATION TO FIELD WITH UVP STRUCTURE" << endl;	
		ifstream fileAdaptField(ffdatadir+"AdaptField.txt");
    	femp2 Sensitivity;	// real and imaginary parts
		fileAdaptField >> Sensitivity[];
				
		cout << " lecture of field with structure P2" << endl;
			
		thnew = adaptmesh(th,Sensitivity,[uBS,vBS,wBS,pBS], /// HERE BUG CORRECTED BY DF : [uBS,vBS,wBS,pBS] (incompressible case) instead of [uBc,vBc,pBc,TBc].
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);		
	}
>>>>>>> master

    femp2xfemp2xfemp1  defP2P2P1(ReP2P2P1Field); // Real P2P2P1 Field
    femp2xfemp2xfemp1 <complex>  defP2P2P1(CxP2P2P1Field); // Complex P2P2P1 Field

<<<<<<< HEAD
    femp2xfemp2xfemp2xfemp1 defP2P2P2P1(ReP2P2P2P1Field); // Real P2P2P2P1 Field2
    femp2xfemp2xfemp2xfemp1 <complex> defP2P2P2P1(CxP2P2P2P1Field); // Complex P2P2P2P1 Field2

    femp2xfemp2xfemp1xfemp1 defP2P2P1P1(ReP2P2P1P1Field); // Real P2P2P1P1 Field2
    femp2xfemp2xfemp1xfemp1 <complex> defP2P2P1P1(CxP2P2P1P1Field); // Complex P2P2P1P1 Field2
=======
	IFMACRO(FREEFEMPLOTS,YES)		
	plot(thold,wait=1);
	plot(thnew,wait=1);
	ENDIFMACRO
	
	savemesh(thnew,ffdatadir+"mesh.msh");
	SFWriteMesh(ffdatadir+"mesh.ff2m",thnew);
	
	savemesh(thnew,ffdatadir+"mesh_adapt.msh");
	SFWriteMesh(ffdatadir+"mesh_adapt.ff2m",thnew);

>>>>>>> master

    femp2xfemp2xfemp1xfemp1xfemp1 defP2P2P1P1P1(ReP2P2P1P1P1Field); // Real P2P2P1P1P1 Field2
    femp2xfemp2xfemp1xfemp1xfemp1<complex> defP2P2P1P1P1(CxP2P2P1P1P1Field); // Complex P2P2P1P1P1 Field2

	
	cout << "###################################" << endl;
	cout << endl << "       Adapt_Mode.edp        " << endl; 
	cout << endl << "###################################" << endl << endl;
	

	cout << endl << "#### Mesh information BEFORE ADAPT :" << endl;  
    cout << "#### Number of vertices    " << th.nv <<  endl;
	
	// Reynolds number
	real Re, Reans;
	
	
	
/// LECTURE FIELDS

		for(int i=0;i<nFields;i++)
		{
			cout << "Reading Field"<<i<< endl;
			ifstream file(ffdatadir+"Field"+i+"_toadapt.txt");
			if(type[i] == "ReP2")
			{
				cout << "Field"<<i<< " is of the type Real P2" << endl;
				file >> ReP2FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(ReP2FieldP2e1),0,0,0];
				defField(FieldImag,i) = [0,0,0,0];
			}
			else if(type[i] == "CxP2")
			{
				cout << "Field"<<i<< " is of the type Complex P2" << endl;
				file >> CxP2FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(CxP2FieldP2e1),0,0,0];
				defField(FieldImag,i) = [imag(CxP2FieldP2e1),0,0,0];
			}
			else if(type[i] == "ReP2P2P1")
			{
				cout << "Field"<<i<< " is of the type Real P2P2P1" << endl;
				file >> ReP2P2P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(ReP2P2P1FieldP2e1),real(ReP2P2P1FieldP2e2),real(ReP2P2P1FieldP1e1),0];
				defField(FieldImag,i) = [0,0,0,0];
			}
			else if(type[i] == "CxP2P2P1")
			{
				cout << "Field"<<i<< " is of the type Complex P2P2P1" << endl;
				file >> CxP2P2P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(CxP2P2P1FieldP2e1),real(CxP2P2P1FieldP2e2),real(CxP2P2P1FieldP1e1),0];
				defField(FieldImag,i) = [imag(CxP2P2P1FieldP2e1),imag(CxP2P2P1FieldP2e2),imag(CxP2P2P1FieldP1e1),0];

			}
			else if(type[i] == "ReP2P2P2P1")
			{
				cout << "Field"<<i<< " is of the type Real P2P2P2P1" << endl;
				file >> ReP2P2P2P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(ReP2P2P2P1FieldP2e1),real(ReP2P2P2P1FieldP2e2),real(ReP2P2P2P1FieldP2e3),real(ReP2P2P2P1FieldP1e1)];
				defField(FieldImag,i) = [0,0,0,0];
			}
			else if(type[i] == "CxP2P2P2P1")
			{
				cout << "Field"<<i<< " is of the type Complex P2P2P2P1" << endl;
				file >> CxP2P2P2P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(CxP2P2P2P1FieldP2e1),real(CxP2P2P2P1FieldP2e2),real(ReP2P2P2P1FieldP2e3),real(ReP2P2P2P1FieldP1e1)];
				defField(FieldImag,i) = [imag(CxP2P2P2P1FieldP2e1),imag(CxP2P2P2P1FieldP2e2),imag(CxP2P2P2P1FieldP2e3),imag(CxP2P2P2P1FieldP1e1)];

			}
			else if(type[i] == "ReP2P2P1P1")
			{
				cout << "Field"<<i<< " is of the type Real P2P2P1P1" << endl;
				file >> ReP2P2P1P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(ReP2P2P1P1FieldP2e1),real(ReP2P2P1P1FieldP2e2),real(ReP2P2P1P1FieldP1e1),real(ReP2P2P1P1FieldP1e2)];
				defField(FieldImag,i) = [0,0,0,0];
			}
			else if(type[i] == "CxP2P2P1P1")
			{
				cout << "Field"<<i<< " is of the type Complex P2P2P1P1" << endl;
				file >> CxP2P2P1P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(CxP2P2P1P1FieldP2e1),real(CxP2P2P1P1FieldP2e2),real(CxP2P2P1P1FieldP1e1),real(CxP2P2P1P1FieldP1e1)];
				defField(FieldImag,i) = [imag(CxP2P2P1P1FieldP2e1),imag(CxP2P2P1P1FieldP2e2),imag(CxP2P2P1P1FieldP1e1),imag(CxP2P2P1P1FieldP1e2)];

			}
			else if(type[i] == "ReP2P2P1P1P1")
			{
				cout << "Field"<<i<< " is of the type Real P2P2P1P1P1" << endl;
				file >> ReP2P2P1P1P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(ReP2P2P1P1P1FieldP2e1),real(ReP2P2P1P1P1FieldP2e2),real(ReP2P2P1P1P1FieldP1e1),real(ReP2P2P1P1P1FieldP1e2)];
				defField(FieldImag,i) = [0,0,0,0];

			}
			else if(type[i] == "CxP2P2P1P1P1")
			{
				// Make a global definition! of variables!!
				cout << "Field"<<i<< " is of the type Complex P2P2P1P1P1" << endl;
				file >> CxP2P2P1P1P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(CxP2P2P1P1P1FieldP2e1),real(CxP2P2P1P1P1FieldP2e2),real(CxP2P2P1P1P1FieldP1e1),real(CxP2P2P1P1P1FieldP1e2)];
				defField(FieldImag,i) = [imag(CxP2P2P1P1P1FieldP2e1),imag(CxP2P2P1P1P1FieldP2e2),imag(CxP2P2P1P1P1FieldP1e1),imag(CxP2P2P1P1P1FieldP1e2)];
			}
			else
				cout << "Field"<<i<< " is ignored" << endl;
			if(i==0)
				Re = Reans;
		}
		mesh thnew;
		thnew = adaptmesh(th,defField(FieldRe,0),defField(FieldImag,0),defField(FieldRe,1),defField(FieldImag,1),
						  defField(FieldRe,2),defField(FieldImag,2),
						  nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,
						  verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);

		// Save the new mesh in msh and ff2m formats
		savemesh(thnew,ffdatadir+"mesh_adapted.msh");
		SFWriteMesh(ffdatadir+"mesh_adapted.ff2m",thnew);

// DECLARATION of NEW FEM SPACE
	fespace femp2N(thnew,P2);   
    fespace femp1N(thnew,P1);
    fespace femp0N(thnew,P0);
    fespace femp2xfemp2xfemp1N(thnew,[P2,P2,P1]);
    fespace femp2xfemp2xfemp1xfemp1N(thnew,[P2,P2,P1,P1]);
    fespace femp2xfemp2xfemp2xfemp1N(thnew,[P2,P2,P2,P1]);
<<<<<<< HEAD
	fespace femp2xfemp2xfemp1xfemp1xfemp1N(thnew,[P2,P2,P1,P1,P1]); /// 

// INTERPOLATION in the NEW mesh of FIELDS

	for(int i=0;i<nFields;i++)
		{
			cout << "Interpolating Field"<<i<< endl;
			ofstream file(ffdatadir+"Field"+i+"_adapted.txt");
			if(type[i] == "ReP2")
			{
				femp2N defP2(ReP2FieldN);
				defP2(ReP2FieldN) = defP2(ReP2Field); // interpolation of structure
				file << ReP2FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "CxP2")
			{
				femp2N<complex> defP2(CxP2FieldN);
				defP2(CxP2FieldN) = defP2(CxP2Field); // interpolation of structure
				file << CxP2FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "ReP2P2P1")
			{
				femp2xfemp2xfemp1N defP2P2P1(ReP2P2P1FieldN);
				defP2P2P1(ReP2P2P1FieldN) = defP2P2P1(ReP2P2P1Field); // interpolation of structure
				file << ReP2P2P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "CxP2P2P1")
			{
				femp2xfemp2xfemp1N <complex>  defP2P2P1(CxP2P2P1FieldN);
				defP2P2P1(CxP2P2P1FieldN) = defP2P2P1(CxP2P2P1FieldN); // interpolation of structure
				file << CxP2P2P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "ReP2P2P2P1")
			{
				femp2xfemp2xfemp2xfemp1N defP2P2P2P1(ReP2P2P2P1FieldN);
				defP2P2P2P1(ReP2P2P2P1FieldN) = defP2P2P2P1(ReP2P2P2P1Field); // interpolation of structure
				file << ReP2P2P2P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "CxP2P2P2P1")
			{
				femp2xfemp2xfemp2xfemp1N<complex> defP2P2P2P1(CxP2P2P2P1FieldN);
				defP2P2P2P1(CxP2P2P2P1FieldN) = defP2P2P2P1(CxP2P2P2P1Field); // interpolation of structure
				file << CxP2P2P2P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "ReP2P2P1P1")
			{
				femp2xfemp2xfemp1xfemp1N defP2P2P1P1(ReP2P2P1P1FieldN);
				defP2P2P1P1(ReP2P2P1P1FieldN) = defP2P2P1P1(ReP2P2P1P1Field); // interpolation of structure
				file << ReP2P2P1P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "CxP2P2P1P1")
			{
				femp2xfemp2xfemp1xfemp1N<complex> defP2P2P1P1(CxP2P2P1P1FieldN);
				defP2P2P1P1(CxP2P2P1P1FieldN) = defP2P2P1P1(CxP2P2P1P1Field); // interpolation of structure
				file << CxP2P2P1P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "ReP2P2P1P1P1")
			{
				femp2xfemp2xfemp1xfemp1xfemp1N defP2P2P1P1P1(ReP2P2P1P1P1FieldN);
				defP2P2P1P1(ReP2P2P1P1P1FieldN) = defP2P2P1P1(ReP2P2P1P1P1Field); // interpolation of structure
				file << ReP2P2P1P1P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "CxP2P2P1P1P1")
			{
				femp2xfemp2xfemp1xfemp1xfemp1N<complex> defP2P2P1P1P1(CxP2P2P1P1P1FieldN);
				defP2P2P1P1P1(CxP2P2P1P1P1FieldN) = defP2P2P1P1P1(CxP2P2P1P1P1Field); // interpolation of structure
				file << CxP2P2P1P1P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
    		}
			cout << "Interpolation of Field"<< i << " has finished" << endl;
		}
=======
    fespace XXxxxHN(thnew,[P2,P2,P1,P1,P1]); /// 
    femp2xfemp2xfemp1N [uNx,uNy,uNp];
    XXxxxHN[uBcN,vBcN,pBcN,TBcN,rhoBcN];
  
    [uNx,uNy,uNp] = [vB,uB,pB]; // interpolation of base flow
//	plot(uBN,fill=1,wait=1);
//	plot(vBN,fill=1,wait=1);
//	plot(pBN,fill=1,wait=1);

	Re = Reans;
	real nu = 1/(Re+1e-30);
	cout << "Writting BaseFlow_guess" << endl;
	if(NdimBaseFlow == NdimUComp) 
	{
		[uBcN,vBcN,pBcN,TBcN,rhoBcN] = [uBc,vBc,pBc,TBc,rhoBc];
		ofstream U(ffdatadir+"BaseFlow_guess.txt");		
		U << uBcN[];
		U << endl << endl <<  Re << endl;
	}
	else{
		[uNx,uNy,uNp] = [vB,uB,pB];
		ofstream U(ffdatadir+"BaseFlow_guess.txt");		
		U << uNx[];
		U << endl << endl <<  Re << endl;

	}

// hack    
    IFMACRO(problemtype,2D)
    cout << " writing BaseFlow_Adapted.ff2m" << endl;
    [uNx,uNy,uNp] = [vB,uB,pB]; 
    plot(uNx,wait=1);
    th = thnew;
	//SFWriteBaseFlow(ffdatadir+"BaseFlow_adaptguess.ff2m",uN,"BaseFlow",1);
		ofstream U(ffdatadir+"BaseFlow_adaptguess.txt");		
        U << uNx[];
        U << endl << endl <<  Re << endl;
	ENDIFMACRO

	IFMACRO(problemtype,AxiXR)
	femp2xfemp2xfemp1N [uNNx,uNNr,uNNp];
	[uNNx,uNNr,uNNp] = [vB,uB,pB];
	th = thnew;
	//SFWriteBaseFlow(ffdatadir+"BaseFlow_Adapted.ff2m",uNN,"BaseFlow",1);
	[uNx,uNy,uNp] = [vB,uB,pB];
	ofstream U(ffdatadir+"BaseFlow_adaptguess.txt");		
        U << uNx[];
        U << endl << endl <<  Re << endl;
	ENDIFMACRO
	
	IFMACRO(problemtype,"2DComp")
	XXxxxHN[uNNc,vNNc,pNNc,TNNc,rhoNNc];
	[uNNc,vNNc,pNNc,TNNc,rhoNNc] = [uBc,vBc,pBc,TBc,rhoBc]; // interpolation of base flow
	SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",uNNc,"BaseFlow",1);
	ENDIFMACRO

// end of hack : this is because SFWriteBaseFlow expects different component names for 2D and axi cases !


// INTERPOLATE THE DATA AND WRITE TO FILE

 
 if(type=="UVP")
   {
	femp2xfemp2xfemp1N<complex> [vCN,uCN,pCN]; 
	[vCN,uCN,pCN] = [vC,uC,pC]; // interpolation of structure
	ofstream U(ffdatadir+"AdaptField_guess.txt");		
    U << vCN[];
    U << endl << endl <<  Re << endl;
   }
   
   else if(type=="UVWP")
   {
	femp2xfemp2xfemp2xfemp1N<complex> [uCCN,vCCN,wCCN,pCCN]; 
	[uCCN,vCCN,wCCN,pCCN] = [uCC,vCC,wCC,pCC]; // interpolation of structure
	ofstream U(ffdatadir+"AdaptField_guess.txt");		
    U << uCCN[];
    U << endl << endl <<  Re << endl;
   }

   else if(type=="Comp")
   {
	XXxxxHN<complex> [ucn,vcn,pcn,Tcn,rhocn]; 
	[ucn,vcn,pcn,Tcn,rhocn] = [uc,vc,pc,Tc,rhoc]; // interpolation of structure
	ofstream U(ffdatadir+"AdaptField_guess.txt");		
	U << ucn[];
	U << endl << endl <<  Re << endl;
   }
   
   else if(type=="Sensitivity")
   {
	femp2N SensitivityN; 
	SensitivityN = Sensitivity; // interpolation of structure
	ofstream U(ffdatadir+"AdaptField_guess.txt");		
   	U << SensitivityN[];
    	U << endl << endl <<  Re << endl;
	cout << "Creating AdaptField_guess.txt" << endl;
   }


 


//	cout << "     copying  interpolated base flow to files BaseFlow_adapt.txt and BaseFlow_guess.txt " 
//	     << endl;
	     
	   
			

	

 		     	 
     	







>>>>>>> master
