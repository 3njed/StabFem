//
//  PROGRAM Adapt_UVP.edp
//  adaptmesh for 2D flow PLUS EIGENMODE
//   
// Usage : FreeFem++ Adapt_Mode.edp "type"
//
//  INPUT PARAMETERS (from pipe) : "type" where types are "ReP2P2P1 CxP2P2P1 ReP2P2P2P1 CxP2P2P2P1
//														   ReP2P2P1P1 CxP2P2P1P1 ReP2P2P1P1P1 CxP2P2P1P1P1" 
// 														 
//
//	INPUT FILES :
// 		mesh_toadapt.msh ->  mesh in Freefem format
//		Fieldi_toadapt.txt	-> Field in type[i] space
// 		Data in this file depends upon option "type"
//			type = "ReP2P2P1" -> Real P2xP2xP1 data (for instance 2D base flow)
//			type = "CxP2P2P1" -> Complex P2xP2xP1 data (for instance 2D mode or 2D base flow with complex mapping)
//			type = "ReP2P2P2P1" -> Real P2xP2xP2xP1 data (for instance 3D base flow)
//			type = "CxP2P2P2P1" -> Complex P2xP2xP2xP1 data (for instance 3D mode or 3D base flow with complex mapping)
//			type = "ReP2P2P1P1" -> Real P2xP2xP1xP1 data (for instance 2D base flow with extra scalar)
//			type = "CxP2P2P1P1" -> Complex P2xP2xP1xP1 data (for instance 2D mode or 2D base flow with complex mapping with an extra scalar)
//			type = "ReP2P2P1P1P1" -> Real P2xP2xP1xP1xP1 data (for instance 2D compressible base flow)
//			type = "CxP2P2P1P1P1" -> Complex P2xP2xP1xP1xP1 data (for instance 2D compressible mode or 2D compressible base flow with complex mapping)
//
//  OUTPUT FILES :
//		mesh_adapted.msh -> New mesh
//		Fieldi_adapted.txt -> Fieldi interpolated on new mesh (guess for next Newton)		
//		Fieldi_toadapt_ans.txt -> Previous Fieldi in the previous mesh in case adaptmesh was not successful
//		mesh_ans.msh -> previous mesh in case adaptmesh was not successful 
// 		nb : BaseFlow.txt is removed, to force new computation with Newton (If baseflow is selected)
// 	ERROR MANAGEMENT : 
//
//  J. Sierra , July 2018
//




	verbosity = 0;
	include "Macros_StabFem.edp";

	int nFields=3; // Number of fields considered for mesh adaptation
	string[int] type(nFields);

	// RUNTIME selection of the Fields
	for (int i=0;i<nFields;i++)
	{
		cout << "Select type of data for Field"<<i<<" ? [ReP2, CxP2, ReP2P2P1 CxP2P2P1 ReP2P2P2P1 CxP2P2P2P1 ReP2P2P1P1P1 CxP2P2P1P1P1 ReP2P2P1P1 CxP2P2P1P1] or None if you do not want Field" << i << endl;
		if(i==0)
			cout << "For Field0. Select a baseflow, a DNS snapshot, HB flow field or any other field containing the Reynolds number at the end of the file" << endl;
		cin >> type[i]; 
	}

	

	// Parameters for adaptmesh functionality
	real Nbvx	= 50000.;		//maximun number of vertices
	real Thetamax	= 1e-3;			//minimum corner angle in degree
	real Verbosity	= 1; // warning : must be integer !
	bool Splitpbedge= false;
//	real Hmin	= .1e-4;           	//minimun edge size 
//	real Hmax	= .5;			//maximun edge size  	
//	real Ratio	= 10.;               	//ratio for the smoothing of the mesh
//	real error	= 1e-2;			//interpolation error level, it decreases on each iteration
// 
// NB ALL THESE PARAMETERS ARE NOW WRITTEN IN THIS FILE :
	include "Param_Adaptmesh.edp";

	// Copy input files
	exec("cp "+ffdatadir+"mesh.msh "+ffdatadir+"mesh_ans.msh");
	exec("cp "+ffdatadir+"mesh.ff2m "+ffdatadir+"mesh_ans.ff2m");
	for (int i=0; i<nFields;++i)
	{
		exec("cp "+ffdatadir+"Field"+i+"_toadapt.txt "+ffdatadir+"Field"+i+"_toadapt_ans.txt ");
	}

	// Read the old mesh	 
	mesh th=readmesh(ffdatadir+"mesh_toadapt.msh");
	mesh thold = th;
	int nvprev = th.nv;

	// Declaration of FEM spaces
	    
	fespace femp2(th,P2);   
    fespace femp1(th,P1);
    fespace femp0(th,P0);
    fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
    fespace femp2xfemp2xfemp1xfemp1(th,[P2,P2,P1,P1]);
    fespace femp2xfemp2xfemp2xfemp1(th,[P2,P2,P2,P1]);
	fespace femp2xfemp2xfemp1xfemp1xfemp1(th,[P2,P2,P1,P1,P1]); /// 

	// Declaration of generic fields

	macro defP2(Field)[Field#P2e1]//EOF
	macro defP2P2P1(Field)[Field#P2e1,Field#P2e2,Field#P1e1]//EOF
	macro defP2P2P2P1(Field)[Field#P2e1,Field#P2e2,Field#P2e3,Field#P1e1]//EOF
	macro defP2P2P1P1(Field)[Field#P2e1,Field#P2e2,Field#P1e1,Field#P1e2]//EOF
	macro defP2P2P1P1P1(Field)[Field#P2e1,Field#P2e2,Field#P1e1,Field#P1e2,Field#P1e3]//EOF

	// Definition of generic macros to be used in adaptmesh
	macro defField(Field,i)[Field#P2e1[i],Field#P2e2[i],Field#P1e1[i],Field#P1e2[i]] //
	macro definitionField(Field)[Field#P2e1,Field#P2e2,Field#P1e1,Field#P1e2] //

	// Generic definition of adaptmesh fields
	femp2xfemp2xfemp1xfemp1[int] definitionField(FieldRe)(nFields);
	femp2xfemp2xfemp1xfemp1[int] definitionField(FieldImag)(nFields);

	femp2 defP2(ReP2Field); // Real P2P2P1 Field
    femp2 <complex> defP2(CxP2Field); // Complex P2P2P1 Field

    femp2xfemp2xfemp1  defP2P2P1(ReP2P2P1Field); // Real P2P2P1 Field
    femp2xfemp2xfemp1 <complex>  defP2P2P1(CxP2P2P1Field); // Complex P2P2P1 Field

    femp2xfemp2xfemp2xfemp1 defP2P2P2P1(ReP2P2P2P1Field); // Real P2P2P2P1 Field2
    femp2xfemp2xfemp2xfemp1 <complex> defP2P2P2P1(CxP2P2P2P1Field); // Complex P2P2P2P1 Field2

    femp2xfemp2xfemp1xfemp1 defP2P2P1P1(ReP2P2P1P1Field); // Real P2P2P1P1 Field2
    femp2xfemp2xfemp1xfemp1 <complex> defP2P2P1P1(CxP2P2P1P1Field); // Complex P2P2P1P1 Field2

    femp2xfemp2xfemp1xfemp1xfemp1 defP2P2P1P1P1(ReP2P2P1P1P1Field); // Real P2P2P1P1P1 Field2
    femp2xfemp2xfemp1xfemp1xfemp1<complex> defP2P2P1P1P1(CxP2P2P1P1P1Field); // Complex P2P2P1P1P1 Field2

	
	cout << "###################################" << endl;
	cout << endl << "       Adapt_Mode.edp        " << endl; 
	cout << endl << "###################################" << endl << endl;
	

	cout << endl << "#### Mesh information BEFORE ADAPT :" << endl;  
    cout << "#### Number of vertices    " << th.nv <<  endl;
	
	// Reynolds number
	real Re, Reans;
	
	
	
/// LECTURE FIELDS

		for(int i=0;i<nFields;i++)
		{
			cout << "Reading Field"<<i<< endl;
			ifstream file(ffdatadir+"Field"+i+"_toadapt.txt");
			if(type[i] == "ReP2")
			{
				cout << "Field"<<i<< " is of the type Real P2" << endl;
				file >> ReP2FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(ReP2FieldP2e1),0,0,0];
				defField(FieldImag,i) = [0,0,0,0];
			}
			else if(type[i] == "CxP2")
			{
				cout << "Field"<<i<< " is of the type Complex P2" << endl;
				file >> CxP2FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(CxP2FieldP2e1),0,0,0];
				defField(FieldImag,i) = [imag(CxP2FieldP2e1),0,0,0];
			}
			else if(type[i] == "ReP2P2P1")
			{
				cout << "Field"<<i<< " is of the type Real P2P2P1" << endl;
				file >> ReP2P2P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(ReP2P2P1FieldP2e1),real(ReP2P2P1FieldP2e2),real(ReP2P2P1FieldP1e1),0];
				defField(FieldImag,i) = [0,0,0,0];
			}
			else if(type[i] == "CxP2P2P1")
			{
				cout << "Field"<<i<< " is of the type Complex P2P2P1" << endl;
				file >> CxP2P2P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(CxP2P2P1FieldP2e1),real(CxP2P2P1FieldP2e2),real(CxP2P2P1FieldP1e1),0];
				defField(FieldImag,i) = [imag(CxP2P2P1FieldP2e1),imag(CxP2P2P1FieldP2e2),imag(CxP2P2P1FieldP1e1),0];

			}
			else if(type[i] == "ReP2P2P2P1")
			{
				cout << "Field"<<i<< " is of the type Real P2P2P2P1" << endl;
				file >> ReP2P2P2P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(ReP2P2P2P1FieldP2e1),real(ReP2P2P2P1FieldP2e2),real(ReP2P2P2P1FieldP2e3),real(ReP2P2P2P1FieldP1e1)];
				defField(FieldImag,i) = [0,0,0,0];
			}
			else if(type[i] == "CxP2P2P2P1")
			{
				cout << "Field"<<i<< " is of the type Complex P2P2P2P1" << endl;
				file >> CxP2P2P2P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(CxP2P2P2P1FieldP2e1),real(CxP2P2P2P1FieldP2e2),real(ReP2P2P2P1FieldP2e3),real(ReP2P2P2P1FieldP1e1)];
				defField(FieldImag,i) = [imag(CxP2P2P2P1FieldP2e1),imag(CxP2P2P2P1FieldP2e2),imag(CxP2P2P2P1FieldP2e3),imag(CxP2P2P2P1FieldP1e1)];

			}
			else if(type[i] == "ReP2P2P1P1")
			{
				cout << "Field"<<i<< " is of the type Real P2P2P1P1" << endl;
				file >> ReP2P2P1P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(ReP2P2P1P1FieldP2e1),real(ReP2P2P1P1FieldP2e2),real(ReP2P2P1P1FieldP1e1),real(ReP2P2P1P1FieldP1e2)];
				defField(FieldImag,i) = [0,0,0,0];
			}
			else if(type[i] == "CxP2P2P1P1")
			{
				cout << "Field"<<i<< " is of the type Complex P2P2P1P1" << endl;
				file >> CxP2P2P1P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(CxP2P2P1P1FieldP2e1),real(CxP2P2P1P1FieldP2e2),real(CxP2P2P1P1FieldP1e1),real(CxP2P2P1P1FieldP1e1)];
				defField(FieldImag,i) = [imag(CxP2P2P1P1FieldP2e1),imag(CxP2P2P1P1FieldP2e2),imag(CxP2P2P1P1FieldP1e1),imag(CxP2P2P1P1FieldP1e2)];

			}
			else if(type[i] == "ReP2P2P1P1P1")
			{
				cout << "Field"<<i<< " is of the type Real P2P2P1P1P1" << endl;
				file >> ReP2P2P1P1P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(ReP2P2P1P1P1FieldP2e1),real(ReP2P2P1P1P1FieldP2e2),real(ReP2P2P1P1P1FieldP1e1),real(ReP2P2P1P1P1FieldP1e2)];
				defField(FieldImag,i) = [0,0,0,0];

			}
			else if(type[i] == "CxP2P2P1P1P1")
			{
				// Make a global definition! of variables!!
				cout << "Field"<<i<< " is of the type Complex P2P2P1P1P1" << endl;
				file >> CxP2P2P1P1P1FieldP2e1[];
				file >> Reans;
				defField(FieldRe,i) = [real(CxP2P2P1P1P1FieldP2e1),real(CxP2P2P1P1P1FieldP2e2),real(CxP2P2P1P1P1FieldP1e1),real(CxP2P2P1P1P1FieldP1e2)];
				defField(FieldImag,i) = [imag(CxP2P2P1P1P1FieldP2e1),imag(CxP2P2P1P1P1FieldP2e2),imag(CxP2P2P1P1P1FieldP1e1),imag(CxP2P2P1P1P1FieldP1e2)];
			}
			else
				cout << "Field"<<i<< " is ignored" << endl;
			if(i==0)
				Re = Reans;
		}
		mesh thnew;
		thnew = adaptmesh(th,defField(FieldRe,0),defField(FieldImag,0),defField(FieldRe,1),defField(FieldImag,1),
						  defField(FieldRe,2),defField(FieldImag,2),
						  nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,
						  verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);

		// Save the new mesh in msh and ff2m formats
		savemesh(thnew,ffdatadir+"mesh_adapted.msh");
		SFWriteMesh(ffdatadir+"mesh_adapted.ff2m",thnew);

// DECLARATION of NEW FEM SPACE
	fespace femp2N(thnew,P2);   
    fespace femp1N(thnew,P1);
    fespace femp0N(thnew,P0);
    fespace femp2xfemp2xfemp1N(thnew,[P2,P2,P1]);
    fespace femp2xfemp2xfemp1xfemp1N(thnew,[P2,P2,P1,P1]);
    fespace femp2xfemp2xfemp2xfemp1N(thnew,[P2,P2,P2,P1]);
	fespace femp2xfemp2xfemp1xfemp1xfemp1N(thnew,[P2,P2,P1,P1,P1]); /// 

// INTERPOLATION in the NEW mesh of FIELDS

	for(int i=0;i<nFields;i++)
		{
			cout << "Interpolating Field"<<i<< endl;
			ofstream file(ffdatadir+"Field"+i+"_adapted.txt");
			if(type[i] == "ReP2")
			{
				femp2N defP2(ReP2FieldN);
				defP2(ReP2FieldN) = defP2(ReP2Field); // interpolation of structure
				file << ReP2FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "CxP2")
			{
				femp2N<complex> defP2(CxP2FieldN);
				defP2(CxP2FieldN) = defP2(CxP2Field); // interpolation of structure
				file << CxP2FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "ReP2P2P1")
			{
				femp2xfemp2xfemp1N defP2P2P1(ReP2P2P1FieldN);
				defP2P2P1(ReP2P2P1FieldN) = defP2P2P1(ReP2P2P1Field); // interpolation of structure
				file << ReP2P2P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "CxP2P2P1")
			{
				femp2xfemp2xfemp1N <complex>  defP2P2P1(CxP2P2P1FieldN);
				defP2P2P1(CxP2P2P1FieldN) = defP2P2P1(CxP2P2P1FieldN); // interpolation of structure
				file << CxP2P2P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "ReP2P2P2P1")
			{
				femp2xfemp2xfemp2xfemp1N defP2P2P2P1(ReP2P2P2P1FieldN);
				defP2P2P2P1(ReP2P2P2P1FieldN) = defP2P2P2P1(ReP2P2P2P1Field); // interpolation of structure
				file << ReP2P2P2P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "CxP2P2P2P1")
			{
				femp2xfemp2xfemp2xfemp1N<complex> defP2P2P2P1(CxP2P2P2P1FieldN);
				defP2P2P2P1(CxP2P2P2P1FieldN) = defP2P2P2P1(CxP2P2P2P1Field); // interpolation of structure
				file << CxP2P2P2P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "ReP2P2P1P1")
			{
				femp2xfemp2xfemp1xfemp1N defP2P2P1P1(ReP2P2P1P1FieldN);
				defP2P2P1P1(ReP2P2P1P1FieldN) = defP2P2P1P1(ReP2P2P1P1Field); // interpolation of structure
				file << ReP2P2P1P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "CxP2P2P1P1")
			{
				femp2xfemp2xfemp1xfemp1N<complex> defP2P2P1P1(CxP2P2P1P1FieldN);
				defP2P2P1P1(CxP2P2P1P1FieldN) = defP2P2P1P1(CxP2P2P1P1Field); // interpolation of structure
				file << CxP2P2P1P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "ReP2P2P1P1P1")
			{
				femp2xfemp2xfemp1xfemp1xfemp1N defP2P2P1P1P1(ReP2P2P1P1P1FieldN);
				defP2P2P1P1(ReP2P2P1P1P1FieldN) = defP2P2P1P1(ReP2P2P1P1P1Field); // interpolation of structure
				file << ReP2P2P1P1P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
			}
			else if(type[i] == "CxP2P2P1P1P1")
			{
				femp2xfemp2xfemp1xfemp1xfemp1N<complex> defP2P2P1P1P1(CxP2P2P1P1P1FieldN);
				defP2P2P1P1P1(CxP2P2P1P1P1FieldN) = defP2P2P1P1P1(CxP2P2P1P1P1Field); // interpolation of structure
				file << CxP2P2P1P1P1FieldNP2e1[];
    			file << endl << endl <<  Re << endl;
    		}
			cout << "Interpolation of Field"<< i << " has finished" << endl;
		}
