//
//  PROGRAM Newton_2D.edp
//  computation of 2D base flow [ur,uz](z,r)
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re
//	INPUT FILES :
//		chbase_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		chbase.txt			-> base flow (FF format)
//		chbase_guess.txt 	-> copy of previous file (in future versions it may be better to manage copies in matlab driver ?)
//      chbase.ff2m         -> base flow (FF2M format) 
//		(cbn_Re##.txt,  chbase_RE##.dat obsolete formats)
// 	ERROR MANAGEMENT : 
//		chbase.txt is not generated if Newton iteration diverges
//
//  THIS VERSION ORIGINATES FROM THE SOURCES BY V. Citro, F. Giannetti & P. Luchini
//
// INCORPORATED INTO THE STABFEM PROJECT BY D. FABRE ON A BUSY DAY AT UNIVERSITA DI SALERNO, 18 july 2017




	     verbosity = 0;
		mesh th=readmesh("mesh.msh");
		
        fespace Xh(th,P2);       //f.e. space for veloecity components
		fespace Mh(th,P1);      //f.e space for pressure
		fespace XXMh(th,[P2,P2,P1]); // f.e. space for triplet [u,v,p]

		XXMh [u1,u2,p];          ///////  -> unknown for the Navier-Stokes problem
		XXMh [v1,v2,q];          ///////  -> test function for Navier-Stokes
		XXMh [up1,up2,pp];   ///////->   buffer vector  to store previous iteration (Newton) 
		XXMh [du1,du2,dp]; 
	real Re;
	real Reans,lecture;

	cout << " Entrer le Nombre de Reynolds :" << endl;
    cin >>  Re;

		{
          ifstream file("chbase_guess.txt");
        file >> u1[];
		file >> Reans;
        };

	cout << " Newton pour Re = " << Re << endl;	
	cout << " CI : " << Reans << endl; 
	real nu=1./Re;
	real eps = 1e-20; // may not be required

int bclat=4,bcinlet=1,bcoutflow=3,bcwall=2,bcaxis=6;

/////////////////////////////////////////////////////////////////////////////////
                         /////// macro to define some useful operators
macro div(u1,u2) (dx(u1)+dy(u2)) // divergence
macro grad(u1,u2) [dx(u1),dy(u2)] // gradient 
macro ugrad(u1,u2,v) (u1*dx(v)+u2*dy(v)) //  [u1,u2]*grad v 
macro Ugrad(ua1,ua2,ub1,ub2) [ugrad(ua1,ua2,ub1),ugrad(ua1,ua2,ub2)] // [u1*dx(v1)+u2*dy(v1),u1*dx(v2)+u2*dy(v2)]
macro Conv(ua1,ua2,ub1,ub2,v1,v2) (Ugrad(ua1,ua2,ub1,ub2)'*[v1,v2]+Ugrad(ub1,ub2,ua1,ua2)'*[v1,v2]) // convection operator
macro Diffusion(nu,u1,u2,v1,v2)  (-nu*( dx(u1)*dx(v1)+dy(u1)*dy(v1)+dx(u2)*dx(v2)+dy(u2)*dy(v2))) // integration by parts of nu (v.Delta u) 

macro Boundaryconditions(u1,u2,v1,v2,symmetry)
	           on(bcinlet,bclat,u1=1.0-up1,u2=0.0) 
             + on(bcwall,u1=0.0,u2=0.0)
             + int1d(Th,bcaxis)(u1*v1*1e30*(symmetry=="A")+u2*v2*1e30*(symmetry=="D"))       
//

//////////////////////////////////////////////////////////////////////////////////
                         /////// linearized system
varf   vDNS ([u1,u2,p],[v1,v2,q]) =
    int2d(th)( nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
                  +   dx(u2)*dx(v2) + dy(u2)*dy(v2) )
                  + p*q*(eps) 
                  - p*(dx(v1)+dy(v2))
                  + (dx(u1)+dy(u2))*q
                //  + Ugrad(u1,u2,up1,up2)'*[v1,v2]
               //   + Ugrad(up1,up2,u1,u2)'*[v1,v2]   
               + Conv(up1,up2,u1,u2,v1,v2)
                )
                  + on(bcinlet,u1=1.0-up1,u2=0.0) 
                  + on(bcwall,u1=0.0,u2=0.0)
                  + on(bcaxis,bclat,u2=0.0);

//////////////////////////////////////////////////////////////////////////////////
                         /////// full N.S. system
varf   vNS ([u1,u2,p],[v1,v2,q]) =
    -int2d(th)( nu * ( dx(up1)*dx(v1) + dy(up1)*dy(v1)
                  +   dx(up2)*dx(v2) + dy(up2)*dy(v2) )
                  + pp*q*(eps) 
                  - pp*(dx(v1)+dy(v2))
                  + (dx(up1)+dy(up2))*q
                  + Ugrad(up1,up2,up1,up2)'*[v1,v2]
                  ) 
                  + on(bcinlet,u1=(1.0-up1),u2=0.0) 
                  + on(bcwall,u1=0.0,u2=0.0)
                  + on(bcaxis,bclat,u2=0.0);



	
	        
	real epsilon=1e-6;
    real tolerance=2e-12;
    int Nitermax=20;
    real ener=10;
//    real res,ener=1.;

		
		int i=0;
        while((ener>tolerance)&(ener<50)&(i<=Nitermax))
        {
	    up1[]=u1[];        ////// Uold=U
////////////////////////////////////////////////
// We want to solve A*x=b
// 
	    matrix Ans=vDNS(XXMh,XXMh); // build matrix 
	    set(Ans,solver=sparsesolver);  //// factorize matrix
	    real[int] b = vNS(0,XXMh);  //////  build r.h.s.
	    real[int] w = Ans^-1*b;       //// system inversion
	    du1[] = w;
	    u1[] += du1[];                     //// update of current solution u1=u1-w
		ener=w.l2;
		ener=sqrt(int2d(th)(du1^2+du2^2)/th.area);
	    cout << " iter = "<< i+1 << "   Re = " << Re << " res = " << ener << endl;
		  
        i++;

	  } ;

// plot 
plot(u1,fill=1,wait=0,value=1,cmm="final U1");
plot(u2,fill=1,wait=0,value=1,cmm="final U2");
plot(p,fill=1,wait=0,value=1,cmm="final Pressure");



// sortie des résultats 


		if((ener>50)||(i>Nitermax))
		{
			cout << " NEWTON ITERATION FAILED" << endl;
			exec("rm chbase.txt");
		}
		else
		{
		  {ofstream file("chbase.txt");
		  file << u1[]; 
		  file << endl << endl << Re;
		  }; 
          exec("cp chbase.txt chbase_guess.txt");    
		};
        
        
  
// POSTPROCESSING FOR THE MATLAB DRIVER 
	
	fespace p1(th,P1);  
	p1 xx,yy;
	xx=x;
	yy=y;
    p1 ut,vt,pt,vort;
	ut=u1;
	vt=u2;
	pt=p;
	
	vort=dy(u1)-dx(u2);

	p1 psi=x,phi;   //psi --> Stream Function phi---> test function


 //evaluate vorticity

 //plot(vort,wait=1);

// Solve Lap(Psi)=-Vort    with Neumann conditions 
 
 real eps1 = 1e-6; 
// solve Laplace(psi,phi, solver = CG) 
// = int2d(th)(dx(psi)*dx(phi)+dy(psi)*dy(phi)+0*eps1*psi*phi)
// - int2d(th)((dx(u2)-dy(u1))*phi)
// - int1d(th,bcinlet,bcoutflow,bclat,bcwall)((-N.x*u2+N.y*u1)*phi);
// to be fixed ??? not working with CG


// POST-TREATMENT FOR SPHERE OR OTHER BODY
if(int1d(th,1)(abs(x)+abs(y))>0)
{
	macro Trainee(u1,u2,p)   
	(
	int1d(th,2,21,22,23)(2*p*N.x)
	-nu*int1d(th,2,21,22,23)( 2*(2*dx(u1)*N.x+(dx(u2)+dy(u1))*N.y))
	)
	//
	real Drag = Trainee(u1,u2,p);
	cout << "#### BLUFF BODY : " << endl; 
	cout << "#    Drag =  " << Drag << endl << endl;
	
	{
	ofstream file("chbase.ff2m");
	real Rpipe = yy[].max;
	    file << "### Data generated by Freefem++ ; " << endl;
    file << "Base flow for a 2D-AXI BLUFF BODY" << endl;
    file << "Format : " << endl;	
	file << "real Re P1 u0 P1 v0 P1 p0 P1 vort0 P1 psi real Drag real iter" << endl << endl ; 
	file << Re << endl;	
			{
			for (int j=0;j<ut[].n ; j++) file << ut[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << pt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vort[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << psi[][j] << endl;
			file << endl <<Drag <<  " " << i << endl;	
		}; 
	}
	
	
};
	
