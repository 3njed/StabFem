//
//  PROGRAM SplitMesh.edp
//  adaptmesh for 2D flow 
//   
// Usage : FreeFem++ SplitMesh.edp 
//
//  INPUT PARAMETERS : nsplit Nfields [Datastoragemode1 Datastoragemode 2...]
//
//	INPUT FILES :
// 		mesh.msh ->  mesh in Freefem format
//		[FlowFieldToAdapt1.txt -> First flowfield to interpolate on new mesh]
//		[FlowFieldToAdapt2.txt -> Second flowfield to interpolate on new mesh]
//      [ ... ]
//
//  OUTPUT FILES :
//		mesh_split.msh -> New mesh
//		mesh_split.ff2m -> associated mesh information file
//		[FlowFieldAdapted1.txt -> First flowfield interpolated on new mesh]
//		[FlowFieldAdapted2.txt -> Second flowfield interpolated on new mesh]
//      [ ... ]
//
//  NB : 1/ program has only been tested for nfields = 0 or 1 (to  be generalised when needed)
//       2/ reading of first file still assumes that "Re" is part of the file... to be suppressed someday ?   
//
// 	ERROR MANAGEMENT : 
//
//  This is part of the StabFem project distributed under gnu licence, Copyright D. Fabre et al., July 2018
//


	verbosity = 0;
	include "Macros_StabFem.edp";




// Input parameters
int nsplit, nfields;
int nfieldsmax = 8;
string[int] datastoragemode(nfieldsmax);

cout << "$$ ###################################" << endl;
cout << endl << "$$       SPLITMESH.edp        " << endl; 
cout << endl << "$$ ###################################" << endl << endl;


cout << "$$ Enter nsplit (refinement order of the mesh)" << endl;
cin >> nsplit ; 
cout << "$$ Enter nfields (number of field to be reinterpolated)" << endl;
cin >> nfields ;
for(int i = 0;i<nfields;i++)
    {
    cout << "$$Enter storage mode of field number " << i  << " ? (string like ReP2P2P1, etc...)" << endl;
    cin >> datastoragemode[i] ;
    };
cout << endl << "$$ Splitting at order " << nsplit << " and adapting " << nsplit << " flowfields" ;
if(nsplit>0) { cout << " with storage mode " << datastoragemode[0] << endl;};
cout << endl << endl;
	
// READ MESH 
	mesh th=readmesh(ffdatadir+"mesh.msh");
	mesh thold = th;
	int nvprev = th.nv;

    cout << endl << "$$#### Mesh information BEFORE SPLIT :" << endl;  
    cout << "$$#### Number of vertices    " << th.nv <<  endl;	

// Declaration of possible data types 

    fespace p2(th,P2);   
    fespace p1(th,P1);
    fespace p0(th,P0);
    fespace p2xp2xp1(th,[P2,P2,P1]);
    fespace p2xp2xp2xp1(th,[P2,P2,P2,P1]);
    fespace p2xp2xp1xp1xp1(th,[P2,P2,P1,P1,P1]);
    fespace p2xp2xp2xp1xp1xp1(th,[P2,P2,P2,P1,P1,P1]);

// All flowfields will be converted to p2xp2xp2xp1xp1xp1<complex> 
    p2xp2xp2xp1xp1xp1<complex>[int] [FTAx,FTAy,FTAz,FTAp,FTAr,FTAT](nfieldsmax); 


//    p2xp2xp1 [vB,uB,pB]; // base flow
//    p2xp2xp2xp1 [vBS,uBS,wBS,pBS]; // base flow        	
//	real Re;
// int NdimUVP = uB[].n;
//    	int NdimUVWP = uBS[].n;
//    	int NdimBaseFlow;
    	real Reans;	
	
	
/// LECTURE OF FIELDS TO ADAPT

for(int i=0;i<nfields;i++) 
    {
    cout << "$$ Lecture of flowfield number " << i+1<< " with structure " <<   datastoragemode[i] << endl;
    ifstream file(ffdatadir+"FlowFieldToAdapt"+(i+1)+".txt");
    
    if(datastoragemode[i]=="ReP2P2P1")
	   {
          p2xp2xp1 [uBx,uBy,uBp]; 
          file >> uBx[]; 
          file >> Reans; 
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),uBy*(1+0i),(0+0i),uBp*(1+0i),(0+0i),(0+0i)];
		}
    else if(datastoragemode[i]=="ReP2P2P2P1")
		{
          p2xp2xp2xp1 [uBx,uBy,uBz,uBp]; 
          file >> uBx[]; 
          file >> Reans;   	
          FTAx[i][] = [uBx*(1+0i),uBy*(1+0i),uBz*(1+0i),uBp*(1+0i),(0+0i),(0+0i)];
		}
    else if(datastoragemode[i]=="ReP2P2P1P1P1")
		{
          p2xp2xp1xp1xp1 [uBx,uBy,uBp,uBrho,uBT]; 
          file >> uBx[];   	
          FTAx[i][] = [uBx*(1+0i),uBy*(1+0i),(0+0i),uBp*(1+0i),uBrho*(1+0i),uBT*(1+0i)];
		}

     else if(datastoragemode[i]=="ReP2P2P2P1P1P1")
		{
          p2xp2xp2xp1xp1xp1 [uBx,uBy,uBz,uBp,uBrho,uBT]; 
          file >> uBx[];   	
          FTAx[i][] = [uBx*(1+0i),uBy*(1+0i),uBz*(1+0i),uBp*(1+0i),uBrho*(1+0i),uBT*(1+0i)];
		}

// else if ... 
/// add your needed case here !

    else
       {
        cout << "$$ ERROR in SF_Split : wrong type of storage mode : " << datastoragemode[i] << endl;   
        exit(-1);
       };
    };


///
/// SPLITTING MESH
///       

	mesh thnew;	
	thnew = splitmesh(th,nsplit);	


IFMACRO(FREEpLOTS,YES)		
	plot(thold,wait=1);
	plot(thnew,wait=1);
ENDIFMACRO



cout << endl << "$$#### Mesh information AFTER SPLIT :" << endl;  
        cout << "$$#### Number of vertices    " << thnew.nv <<  endl;
	   // cout << "$$### Dimension of matrices " << vB[].n << endl << endl;


	savemesh(thnew,ffdatadir+"mesh_split.msh");
	SFWriteMesh(ffdatadir+"mesh_split.ff2m",thnew);


///	
/// INTERPOLATE FLOW FIELDS AND SAVE TO FILE
///

    fespace p2N(thnew,P2);   
    fespace p1N(thnew,P1);
    fespace p0N(thnew,P0);
 	fespace p2xp2xp1N(thnew,[P2,P2,P1]);
 	fespace p2xp2xp2xp1N(thnew,[P2,P2,P2,P1]);
    fespace p2xp2xp1xp1xp1N(thnew,[P2,P2,P1,P1,P1]);
    fespace p2xp2xp2xp1xp1xp1N(thnew,[P2,P2,P2,P1,P1,P1]);

for(int i=0;i<nfields;i++) 
    {
    cout << "$$ Interpolating and writing flowfield number " << i+1<< " with structure " <<   datastoragemode[i] << endl;
    ofstream U(ffdatadir+"FlowFieldAdapted"+(i+1)+".txt");
	
    if(datastoragemode[i]=="ReP2P2P1")
	   {
          p2xp2xp1N [uBNx,uBNy,UBNp]=[real(FTAx[i]),real(FTAy[i]),real(FTAp[i])]; 
          U << uBNx[]; 
          U << Reans;   
		}
    else if(datastoragemode[i]=="ReP2P2P2P1")
        {
          p2xp2xp2xp1N [uBNx,uBNy,UBNz,UBNp]=[real(FTAx[i]),real(FTAy[i]),real(FTAz[i]),real(FTAp[i])]; 
          U << uBNx[]; 
          U << Reans;
        }
    else if(datastoragemode[i]=="ReP2P2P1P1P1")
        {
          p2xp2xp1xp1xp1N [uBNx,uBNy,uBNp,uBNrho,uBNT]=[real(FTAx[i]),real(FTAy[i]),real(FTAp[i]),real(FTAr[i]),real(FTAT[i])];
          U << uBNx[]; 
          U << Reans;
        }
    else if(datastoragemode[i]=="ReP2P2P2P1P1P1")
        {
          p2xp2xp2xp1xp1xp1N [uBNx,uBNy,uBNz,uBNp,uBNrho,uBNT]=[real(FTAx[i]),real(FTAy[i]),real(FTAz[i]),real(FTAp[i]),real(FTAr[i]),real(FTAT[i])];
          U << uBNx[]; 
          U << Reans;
        }
   }

cout << "$$ FreeFem : Successfully Leaving function   SplitMesh.edp   "  <<  endl;
   




