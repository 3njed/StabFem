//
//  PROGRAM Adapt_UVP.edp
//  adaptmesh for 2D flow PLUS EIGENMODE
//   
//
//  INPUT PARAMETERS (from pipe) :
//   	Eigenmode.txt One file containing [P2,P2,P2,P1] field)
// 			syntax : FreeFem++ Adapt_UVWP.edp < Eigenmode.txt
//	INPUT FILES :
// 		mesh_ans.msh 			->  mesh in Freefem format
//		chbase.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
//  OUTPUT FILES :
//		chbase_adaptguess.txt			
//		mesh.msh 
//		Eigenmode_guess.txt -> may be useful to provide initial guess for Shift/invert solver
// 		nb : chbase.txt and Eigenmode_guess.txt are destroyed, to avoid wrong usage	
//      ( copies mesh_guess.msh mesh.msh chbase_guess.txt ; are they still useful ?)
// 	ERROR MANAGEMENT : 
//
//  D. Fabre et al., June 2017
//
// THIS PROGRAM IS IDENTICAL TO Adapt_UVWP.edp EXCEPT FOR DATA FORMAT : p2p2p1 instead of p2p2p2p1



	verbosity = 0;
	string AAA = "FreeFem++";

//include "Params_Conduct.edp";

    
    
    
    
    
    real Nbvx	= 50000.;		//maximun number of vertices
//	real Hmin	= .1e-4;           	//minimun edge size 
//	real Hmax	= .5;			//maximun edge size  	
//	real Ratio	= 10.;               	//ratio for the smoothing of the mesh
	real Thetamax	= 1e-3;			//minimum corner angle in degree
	real Verbosity	= 1; // warning : must be integer !
	bool Splitpbedge= false;
//	real error	= 1e-2;			//interpolation error level, it decreases on each iteration

include "Param_Adaptmesh.edp";

	mesh th=readmesh("mesh_ans.msh");
	int nvprev = th.nv;
	    fespace femp2(th,P2);   
        fespace femp1(th,P1);
        fespace femp0(th,P0);
        fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
        fespace femp2xfemp2xfemp2xfemp1(th,[P2,P2,P2,P1]);
        femp2xfemp2xfemp1 [vB,uB,pB]; // base flow
        femp2xfemp2xfemp1<complex> [vC,uC,pC];	// structure of forced problem (complex)
        femp2xfemp2xfemp1 [v,u,p], [vi,ui,pii],[vBR,uBR,pBR];	// real and imaginary parts
	
	cout << "###################################" << endl;
cout << endl << "       Adapt_UVP.edp        " << endl; 
cout << endl << "###################################" << endl << endl;

	
	
	real Re;
	
	{
	ifstream U("chbase_ans.txt");		
	U >> vB[];
	U >> Re;
	}
    cout << " lecture of Base flow : Reynolds number = " << Re << endl;


cin >> uC[];
cin >> Re;

//[v,u,p] = [real(vC)/abs(vC)*exp(-y^2),real(uC)/abs(uC)*exp(-y^2),real(pC)/abs(pC)*exp(-y^2)];

//[v,u,p] = [real(pC)/abs(pC)*exp(-y^2),real(pC)/abs(pC)*exp(-y^2),real(pC)/abs(pC)*exp(-y^2)];

//[v,u,p] = [real(vC)*exp(-y^2),real(uC)*exp(-y^2),real(pC)/abs(pC)*exp(-y^2)];

[v,u,p] = [real(vC),real(uC),real(pC)];
[vi,ui,pii] = [imag(vC),imag(uC),imag(pC)];


cout << " lecture of field [V,U,P] from standart input for RE = " << Re;
if(ui[].max<1e-6){ cout << " (Real field ; most likely a base flow) " << endl;}
else{  cout << " (complex field ; most likely an eigenmode or response to a forcing) "<< endl; };


//cout << "SINGLE MESH ADAPTATION ; " << endl; 

//cout << " Reynolds number = " << Re << endl;


cout << endl << "#### Mesh information BEFORE ADAPT :" << endl;  
        cout << "#### Number of vertices    " << th.nv <<  endl;
	    cout << "### Dimension of matrices " << v[].n << endl << endl;


	
	

///////////////////////////////////////////////////////////////////////////////////////////////////
// Calcul des champs de base //////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

/*
	string date;
	{date=exec("date +%d/%m-%H:%M");}                 
	
	{ofstream log("log.txt",append);	//output log file, usefull if you want to  			
	log << endl << endl;			//check adaptMesh's settings
	log <<  "/////////////////////////////////////////////////////////" <<endl;
	log <<  "/////////////////////New calculation/////////////////////" <<endl;		
	log <<  "/////////////////////////////////////////////////////////" <<endl;	
	log <<  "// Date                = "<< date                          <<endl;
	log <<  "// Nbvx                = "<< Nbvx                          <<endl;		
	log <<	"// Hmin                = "<< Hmin                          <<endl;   	
	log <<	"// Hmax                = "<< Hmax                          <<endl;	
	log <<	"// Ratio               = "<< Ratio                         <<endl;         	
	log <<	"// Thetamax            = "<< Thetamax                      <<endl;		
	log <<	"// Verbosity           = "<< Verbosity                     <<endl;
	log <<	"// Splitpbedge         = "<< Splitpbedge                   <<endl;
	log <<	"// error               = "<< error                         <<endl;	
	log <<	"// error ratio         = "<< rr                            <<endl;	
	log <<  "/////////////////////////////////////////////////////////" <<endl<<endl;}
*/		
	
real Lcut=2;	
			cout << " dim of u[] before adapt : " << u[].n <<  endl;
			
			mesh thold = th;
			mesh thnew;				
thnew = adaptmesh(th,[v,u,p],[vi,ui,pii],[vB,uB,pB],
nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2);
			
			cout << endl << "...............New mesh created..............." << endl << endl;




   fespace femp2N(thnew,P2);   
        fespace femp1N(thnew,P1);
        fespace femp0N(thnew,P0);
        fespace femp2xfemp2xfemp2xfemp1N(thnew,[P2,P2,P2,P1]);
        fespace femp2xfemp2xfemp1N(thnew,[P2,P2,P1]);
        femp2xfemp2xfemp1N [vN,uN,pN];
        femp2xfemp2xfemp1N [vBN,uBN,pBN];
        [vN,uN,pN] = [v,u,p]; // interpolation of structure
       	[vBN,uBN,pBN] = [vB,uB,pB]; // interpolation of base flow

cout << endl << "#### Mesh information AFTER ADAPT :" << endl;  
        cout << "#### Number of vertices    " << thnew.nv <<  endl;
	    cout << "### Dimension of matrices " << vN[].n << endl << endl;
					


cout << "### Number of DOF : " << vBN[].n << endl << endl;  
	cout << "#### MESH INFO : " << endl<< endl ; 
	femp1N delta = hTriangle;
	cout << "delta min : " << delta[].min << endl;
	cout << "delta max : " << delta[].max << endl;
	cout << "delta(0,.5) : ( boundary layer) : " << delta(0,.5) << endl ;
	cout << "delta(2.5,.5) : ( sensitivity) : " << delta(2.5,.5) << endl ;
	cout << "delta(4,0) : ( wake ) : " << delta(4,0) << endl << endl ;
    cout << "delta(10,0) : ( far wake ) : " << delta(10,0) << endl << endl ;







//	cout << "     copying  interpolated base flow to files chbase_adapt.txt and chbase_guess.txt " 
//	     << endl;
	     
	   
			

	savemesh(thnew,"mesh_adapt.msh");

 real[int] xprobe = [0,	2.5,	4,	10];
    	real[int] yprobe = [.5, 	.5,	0,	0];
     	 
     	 {
     	 cout << "Writing mesh_adapt.ff2m" << endl;
 		 ofstream fileFF("mesh_adapt.ff2m");
 		 fileFF << "### MESH generated by Freefem++ ; " << endl;
    	 fileFF << "2D" << endl;
    	 fileFF << "Format :" << endl;
	     fileFF << "int np int Ndof real deltamin real deltamax real deltaA real deltaB real deltaC real deltaD int AdaptGeneration" 
	     << endl << endl ; 
		 fileFF << thnew.nv <<  endl << vBN[].n << endl ;
		 fileFF << delta[].min << endl;
		 fileFF << delta[].max << endl;
		 for(int ii = 0; ii<4;ii++)
		 	{ fileFF << delta(xprobe(ii),yprobe(ii)) << endl ;}
    	 fileFF << 1 << endl;	
 		 };






	

	
cout << "...............New mesh  saved..............." << endl;

	     
		{
		ofstream U("chbase_adaptguess.txt");		
        U << vBN[];
        U << endl << endl <<  Re << endl;
	  	}
	  	
	  	{
		ofstream U("Eigenmode_guess.txt");		
        U << vN[];
        U << endl << endl <<  Re << endl;
	  	}


 //        exec("cp chbase_adaptCOMPLEX.txt chbase_guessCOMPLEX.txt");			
//	 exec("cp mesh_adapt.msh mesh_guess.msh");

//	 exec("cp mesh_adapt.msh mesh.msh");
	 exec("rm chbase.txt");  

			plot(thold,wait=1);
			plot(thnew,wait=1);

			plot(uBN,fill=1,wait=1);
			plot(vBN,fill=1,wait=1);
			plot(pBN,fill=1,wait=1);

			plot(uN,fill=1,wait=1);
			plot(vN,fill=1,wait=1);
			plot(pN,fill=1,wait=1);



