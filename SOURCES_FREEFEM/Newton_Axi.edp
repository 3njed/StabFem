//
//  PROGRAM Newton_Axi.edp
//  computation of axisymmetric base flow [ur,uz](z,r)
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//		BaseFlow_guess.txt 	-> copy of previous file (in future versions it may be better to manage copies in matlab driver ?)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//		(cbn_Re##.txt,  BaseFlow_RE##.dat obsolete formats)
// 	ERROR MANAGEMENT : 
//		BaseFlow.txt is not generated if Newton iteration diverges

//  D. Fabre et al., June 2017




	           verbosity = 0;
	mesh th=readmesh("mesh.msh");
        fespace femp2(th,P2);   
        fespace femp1(th,P1);
        fespace femp0(th,P0);
        fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
        femp2xfemp2xfemp1 [u2,u1,p];

	real Re;
	real Reans,lecture;

	cout << " Entrer le Nombre de Reynolds :" << endl;

        cin >> lecture; 
	
	if (lecture == 0)
	{
	ifstream file("Reynolds.txt");
	file >> Re;
	  }
	else
	   {
		Re = lecture;
	  };
	
	{
          ifstream file("BaseFlow_guess.txt");
        file >> u2[];
	file >> Reans;
        };

	cout << " Newton pour Re = " << Re << endl;	
	cout << " CI : " << Reans << endl; 
	

    femp2xfemp2xfemp1 [urp,uzp,pp]=[u2,u1,p];
	femp2xfemp2xfemp1 [dur,duz,dp],[vr,vz,q];
	real nu=1./Re;
        
	real epsilon=1e-6;
        real residuNewton=2e-12;
        int Nitermax=14;

        real res,ener=1.;

// impose inlet conditions for birdcall
//		real Ud = (1.5*3.444/0.5)^-2; 
		real Ud;
//		real Sin = int1d(th,11)(y)*2*pi;

	   if(int1d(th,91)(abs(x)+abs(y))>0)
			{
		Ud = (2*pi*int1d(th,91)(y))/(2*pi*int1d(th,11)(y));
			};

		// should find a better way to impose it
		
	int i=0;
        while((ener>residuNewton)&(ener<50)&(i<=Nitermax))
        {
    
real G=1;real Gy=1;

solve NS([dur,duz,dp],[vr,vz,q])=
	// gradient
	int2d(th)(
        (  y*vz*(uzp*G*dx(duz)+duz*G*dx(uzp)+urp*Gy*dy(duz)+dur*Gy*dy(uzp) )
         + y*vr*(uzp*G*dx(dur)+duz*G*dx(urp)+urp*Gy*dy(dur)+dur*Gy*dy(urp) )
  + nu*(y*G*dx(duz)*G*dx(vz)+y*Gy*dy(duz)*Gy*dy(vz)  
	      + y*G*dx(dur)*G*dx(vr)+y*Gy*dy(dur)*Gy*dy(vr)+1/y*dur*vr  )
	- dp*(y*G*dx(vz)+vr+y*Gy*dy(vr))
	+ q*(y*G*dx(duz)+dur+y*Gy*dy(dur))
        )*1/(Gy*G)
	)
	// second membre
 	+ int2d(th)(
 	         (
	 y*(   vr*urp*Gy*dy(urp)+vr*uzp*G*dx(urp)
	     + vz*urp*Gy*dy(uzp)+vz*uzp*G*dx(uzp)  )     
	+ nu*(y*G*dx(uzp)*G*dx(vz)+y*Gy*dy(uzp)*Gy*dy(vz)  
	      + y*G*dx(urp)*G*dx(vr)+y*Gy*dy(urp)*Gy*dy(vr)+1/y*urp*vr  )
        - pp*(y*G*dx(vz)+vr+y*Gy*dy(vr))
        + q*(y*G*dx(uzp)+urp+y*Gy*dy(urp)) 
        )*1/(Gy*G)
        )
  	+on(1,duz=1.-uzp,dur=-urp) // inlet (ux=1)
	+on(11,duz=Ud-uzp,dur=-urp) // inlet (flux = 1)
  	+on(2,21,22,23,duz=-uzp,dur=-urp)
	+on(6,dur=-urp) // axis
	+on(7,dur=-urp); // lateral wall cavity
	

		  ener=sqrt(int2d(th)(dur^2+duz^2)/th.area);
		  
		  cout << " res = " << ener << endl;
                urp[]+=dur[];
        i++;
	}

// sortie des résultats 
//		  {
//		   ofstream file("WORK/RES_newton.txt",append);
//		   file << i << "   " << ener << endl;
//		  };

		if((ener>50)||(i>=Nitermax))
		{
			cout << " NEWTON ITERATION FAILED" << endl;
			exec("rm BaseFlow.txt");
		}

		else
		{

		 {
		  ofstream file("BaseFlow.txt");
		  file << urp[]; 
		  file << endl << endl << Re; // remis
         };
          exec("cp BaseFlow.txt BaseFlow_guess.txt");      
		
		plot(uzp);
	
	femp1 xx,yy;
	xx=x;
	yy=y;

    femp1 ut,vt,pt,vort;
	ut=uzp;
	vt=urp;
	pt=p;
	vort=dx(vt)-dy(ut);




// POST-TREATMENT FOR SPHERE OR OTHER BODY
if(int1d(th,1)(abs(x)+abs(y))>0)
{
	macro Trainee(ur,uz,p)   
	(
	int1d(th,2,21,22,23)(p*2*pi*y*N.x)
	-nu*int1d(th,2,21,22,23)( (2*dx(uz)*N.x+(dx(ur)+dy(uz))*N.y)*2*pi*y)
	)
	//
	real Drag = Trainee(urp,uzp,pp);
	cout << "#### BLUFF BODY : " << endl; 
	cout << "#    Drag =  " << Drag << endl << endl;
	
	{
	ofstream file("BaseFlow.ff2m");
	real Rpipe = yy[].max;
	    file << "### Data generated by Freefem++ ; " << endl;
    file << "Base flow for a 2D-AXI BLUFF BODY" << endl;
    file << "Format : " << endl;	
	file << "real Re P1 u0 P1 v0 P1 p0 P1 vort0 real Drag real iter" << endl << endl ; 
	file << Re << endl;	
			{
			for (int j=0;j<ut[].n ; j++) file << ut[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << pt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vort[][j] << endl;
			file << endl <<Drag <<  " " << i << endl;	
		}; 
	}
	
	
};
	
// POST-TREATMENT FOR WHISTLING JET	
if(int1d(th,91)(abs(x)+abs(y))>0)
{
	real Umeaninlet = int1d(th,11)(uzp*y)/(int1d(th,11)(y)+1e-20);
	real Umean1 =int1d(th,91)(uzp*y)/(int1d(th,91)(y)+1e-20);
	real Umean2 =int1d(th,92)(uzp*y)/(int1d(th,92)(y)+1e-20);
	real deltaP0 = pp(-5,5)-pp(15,5);
	real Q0 = int1d(th,11)(uzp*y)*2*pi;
    cout << "#### JET ACROSS ONE OR TWO HOLES : " << endl; 
	cout << "# Flow rate across inlet : " << Q0 << endl;
	cout << "# Flow rate across hole 1 : " << int1d(th,91)(uzp*y)*2*pi << endl;
	cout << "# Flow rate across hole 1 : " << int1d(th,92)(uzp*y)*2*pi << endl << endl;
	cout << "# Mean velocity across inlet  : " << Umeaninlet << endl;
	cout << "# Mean velocity across hole 1 : " << Umean1 << endl;
	cout << "# Mean velocity across hole 2 : " << Umean2 << endl;
	cout << "# Delta P tot : " << deltaP0 << endl;
	real CD = Umean1/sqrt(2*deltaP0);
	real alphaVC = 1/CD;
	cout << "# Venna-contracta coefficient  alpha : " << alphaVC << endl;
	cout << "# Discharge coefficient CD = " << CD << endl << endl;
	
	{
	ofstream file("BaseFlow.ff2m");
	real Rpipe = yy[].max;
	    file << "### Data generated by Freefem++ ; " << endl;
    file << "Base flow for a JET through one or two holes" << endl;
    file << "Format : " << endl;	
	file << "real Re P1 u0 P1 v0 P1 p0 P1 vort0 real Umean1 real Q0 real deltaP0 real CD real alpha real iter" << endl << endl ; 
	file << Re << endl;	
			{
			for (int j=0;j<ut[].n ; j++) file << ut[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << pt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vort[][j] << endl;
			file << endl << Umean1 << " " << Q0 << " " << deltaP0 << " " << CD << " " << alphaVC << " " << i << endl;	
			
		}; 
	}
	
};
	 
	
	
//// EXPORTATION DU CHAMP DE BASE AUX FORMATS TECPLOT ET MATLAB
//	{
//	ofstream champ2D("BaseFlow_RE"+Re+".dat");
//	{
//		champ2D << "VARIABLES= \"x\" , \"y\" , \"u\" , \"v\" , \"p\" , \"om\" "<< endl;
//		champ2D << "ZONE F=FEPOINT,ET=TRIANGLE,N=" << th.nv << ",E=" << th.nt << endl;
//	
//		for (int j=0; j<th.nv; j++)
//		{
//			champ2D << xx[][j] << " " << yy[][j]  << " " << ut[][j] <<  " " << vt[][j] << " " << pt[][j] << " " << vort[][j] << endl;
//		}; 
//
//		for (int i=0; i<th.nt; i++)
//		{ 
//			champ2D << th[i][0]+1 << " " << th[i][1]+1 << " " << th[i][2]+1 << endl;
//		};
//	};
//	}


	
		};
		
//cout << "END CONVERSION" << endl;

	
