//
//  PROGRAM Newton_Axi.edp
//  computation of axisymmetric base flow [ur,uz](z,r)
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re
//	INPUT FILES :
//		chbase_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		chbase.txt			-> base flow (FF format)
//		chbase_guess.txt 	-> copy of previous file (in future versions it may be better to manage copies in matlab driver ?)
//      chbase.ff2m         -> base flow (FF2M format) 
//		(cbn_Re##.txt,  chbase_RE##.dat obsolete formats)
// 	ERROR MANAGEMENT : 
//		chbase.txt is not generated if Newton iteration diverges

//  D. Fabre et al., June 2017

// NB this program contains customized output for two kind of problems :
//		A/ flow around bluff bodies (sphere, etc...)
//		B/ jet through (one or two holes) 
// 	selection is done according to the label of boundary : if inlet = 1 -> case A, if inlet =11 -> case B
//  (customisation handling is to improved in future versions ?)


	           verbosity = 0;
	mesh th=readmesh("mesh.msh");
        fespace femp2(th,P2);   
        fespace femp1(th,P1);
        fespace femp0(th,P0);
        fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
        femp2xfemp2xfemp1 [u2,u1,p];

	real Re;
	real Reans,lecture;
	
		cout << "###################################" << endl;
cout << endl << "       Newton_Axi.edp        " << endl; 
cout << endl << "###################################" << endl << endl;



	cout << " Entrer le Nombre de Reynolds :" << endl;

        cin >> lecture; 
	
	if (lecture == 0)
	{
	ifstream file("Reynolds.txt");
	file >> Re;
	  }
	else
	   {
		Re = lecture;
	  };
	
	{
          ifstream file("chbase_guess.txt");
        file >> u2[];
	file >> Reans;
        };

	cout << " Newton pour Re = " << Re << endl;	
	cout << " CI : " << Reans << endl; 
	

    femp2xfemp2xfemp1 [urp,uzp,pp]=[u2,u1,p];
	femp2xfemp2xfemp1 [dur,duz,dp],[vr,vz,q];
	real nu=1./Re;
        
	real epsilon=1e-6;
        real residuNewton=2e-12;
        int Nitermax=14;

        real res,ener=1.;

// impose inlet conditions for birdcall
//		real Ud = (1.5*3.444/0.5)^-2; 
		real Ud;
//		real Sin = int1d(th,11)(y)*2*pi;
//		if(Sin!=0)
//			{
		Ud = (2*pi*int1d(th,91)(y))/(2*pi*int1d(th,11)(y)+1e-30);
//			}

		// should find a better way to impose it
		
	int i=0;
        while((ener>residuNewton)&(ener<50)&(i<=Nitermax))
        {
        	/*
	solve NS([dur,duz,dp],[vr,vz,q])=
	// gradient
    	int2d(th)(
        y^2*vz*(uzp*dx(duz)+duz*dx(uzp)+urp*dy(duz)+dur*dy(uzp) )
        + y^2*vr*(uzp*dx(dur)+duz*dx(urp)+urp*dy(dur)+dur*dy(urp))
        + nu*(y^2*dx(duz)*dx(vz)+y^2*dy(duz)*dy(vz)+y*dy(duz)*vz
        + y^2*dx(dur)*dx(vr)+y^2*dy(dur)*dy(vr)+dur*vr+y*dy(dur)*vr)
	- dp*(y^2*dx(vz)+2*y*vr+y^2*dy(vr))
	+ q*(y*dx(duz)+dur+y*dy(dur))
        )
	// second membre
 	- int2d(th)(
        - nu*(y^2*dx(uzp)*dx(vz)+y^2*dy(uzp)*dy(vz)+y*dy(uzp)*vz
        + y^2*dx(urp)*dx(vr)+y^2*dy(urp)*dy(vr)+urp*vr+y*dy(urp)*vr)
        + pp*(y^2*dx(vz)+2*y*vr+y^2*dy(vr))
	- y^2*(vr*urp*dy(urp)+vr*uzp*dx(urp)
        + vz*urp*dy(uzp)+vz*uzp*dx(uzp))
        - q*(y*dx(uzp)+urp+y*dy(urp))    
        )
  	+on(1,duz=1.-uzp,dur=-urp) // inlet (ux=1)
	+on(11,duz=Ud-uzp,dur=-urp) // inlet (flux = 1)
  	+on(2,21,22,23,duz=-uzp,dur=-urp)
	+on(6,7,dur=-urp);
*/

real G=1;real Gy=1;

solve NS([dur,duz,dp],[vr,vz,q])=
	// gradient
	int2d(th)(
        (  y*vz*(uzp*G*dx(duz)+duz*G*dx(uzp)+urp*Gy*dy(duz)+dur*Gy*dy(uzp) )
         + y*vr*(uzp*G*dx(dur)+duz*G*dx(urp)+urp*Gy*dy(dur)+dur*Gy*dy(urp) )
  + nu*(y*G*dx(duz)*G*dx(vz)+y*Gy*dy(duz)*Gy*dy(vz)  
	      + y*G*dx(dur)*G*dx(vr)+y*Gy*dy(dur)*Gy*dy(vr)+1/y*dur*vr  )
	- dp*(y*G*dx(vz)+vr+y*Gy*dy(vr))
	+ q*(y*G*dx(duz)+dur+y*Gy*dy(dur))
        )*1/(Gy*G)
	)
	

	// second membre
 	+ int2d(th)(
 	         (
	 y*(   vr*urp*Gy*dy(urp)+vr*uzp*G*dx(urp)
	     + vz*urp*Gy*dy(uzp)+vz*uzp*G*dx(uzp)  )
	     
	+ nu*(y*G*dx(uzp)*G*dx(vz)+y*Gy*dy(uzp)*Gy*dy(vz)  
	      + y*G*dx(urp)*G*dx(vr)+y*Gy*dy(urp)*Gy*dy(vr)+1/y*urp*vr  )
	
        - pp*(y*G*dx(vz)+vr+y*Gy*dy(vr))
	
        + q*(y*G*dx(uzp)+urp+y*Gy*dy(urp)) 
        )*1/(Gy*G)
        )
  	+on(1,duz=1.-uzp,dur=-urp) // inlet (ux=1)
	+on(11,duz=Ud-uzp,dur=-urp) // inlet (flux = 1)
  	+on(2,21,22,23,duz=-uzp,dur=-urp)
	+on(6,dur=-urp) // axis
	+on(7,dur=-urp); // lateral wall cavity
	




		  ener=sqrt(int2d(th)(dur^2+duz^2)/th.area);
		  
		  cout << " res = " << ener << endl;
                urp[]+=dur[];
        i++;
	}

// sortie des résultats 
//		  {
//		   ofstream file("WORK/RES_newton.txt",append);
//		   file << i << "   " << ener << endl;
//		  };

		if((ener>50)||(i>=Nitermax))
		{
			cout << " NEWTON ITERATION FAILED" << endl;
			exec("rm chbase.txt");
		}
		else
		{

//		 {
//		  ofstream file("cbn_Re"+Re+".txt");
//		  file << urp[];
//		  file << Re; // remis 
//        };
//          exec("mv cbn_Re"+Re+".txt CHBASE/");

		 {
		  ofstream file("chbase.txt");
		  file << urp[]; 
		  file << endl << endl << Re; // remis
         };
          exec("cp chbase.txt chbase_guess.txt");      
	
	
		plot(uzp);
	
	femp1 xx,yy;
	xx=x;
	yy=y;

    femp1 ut,vt,pt,vort;
	ut=uzp;
	vt=urp;
	pt=p;
	vort=dx(vt)-dy(ut);



// POST-TREATMENT FOR SPHERE OR OTHER BODY


	macro Trainee(ur,uz,p)   
	(
	int1d(th,2,21,22,23)(p*2*pi*y*N.x)
	-nu*int1d(th,2,21,22,23)( (2*dx(uz)*N.x+(dx(ur)+dy(uz))*N.y)*2*pi*y)
	)
	//
	
	real truc = int2d(th,45)(y);
	
// POST-TREATMENT FOR WHISTLING JET	
	real Drag = Trainee(urp,uzp,pp);
	cout << "#### Drag =  " << Drag << endl;
	
	real Umeaninlet = int1d(th,11)(uzp*y)/(int1d(th,11)(y)+1e-20);
	real Umean1 =int1d(th,91)(uzp*y)/(int1d(th,91)(y)+1e-20);
	real Umean2 =int1d(th,92)(uzp*y)/(int1d(th,92)(y)+1e-20);
	
	cout << " Flow rate : " << int1d(th,91)(uzp*y)*2*pi << " " << int1d(th,11)(uzp*y) << endl;
	cout << " Mean velocity across inlet  : " << Umeaninlet << endl;
	cout << " Mean velocity across hole 1 : " << Umean1 << endl;
	cout << " Mean velocity across hole 2 : " << Umean2 << endl;

	 
	
	
//// EXPORTATION DU CHAMP DE BASE AUX FORMATS TECPLOT ET MATLAB
//	{
//	ofstream champ2D("chbase_RE"+Re+".dat");
//	{
//		champ2D << "VARIABLES= \"x\" , \"y\" , \"u\" , \"v\" , \"p\" , \"om\" "<< endl;
//		champ2D << "ZONE F=FEPOINT,ET=TRIANGLE,N=" << th.nv << ",E=" << th.nt << endl;
//	
//		for (int j=0; j<th.nv; j++)
//		{
//			champ2D << xx[][j] << " " << yy[][j]  << " " << ut[][j] <<  " " << vt[][j] << " " << pt[][j] << " " << vort[][j] << endl;
//		}; 
//
//		for (int i=0; i<th.nt; i++)
//		{ 
//			champ2D << th[i][0]+1 << " " << th[i][1]+1 << " " << th[i][2]+1 << endl;
//		};
//	};
//	}


	{
	ofstream file("chbase.ff2m");
	real Rpipe = yy[].max;
	    file << "### Data generated by Freefem++ ; " << endl;
    file << "Base flow for a disk or radius 0.5 and thickness Hdisk in a pipe of radius Rpipe" << endl;
    file << "Format : " << endl;	
	file << "real Re P1 u0 P1 v0 P1 p0 P1 vort0 real Drag" << endl << endl ; 
	file << Re << endl;	
			{
			for (int j=0;j<ut[].n ; j++) file << ut[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << pt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vort[][j] << endl;
			file << endl <<Drag << endl;	
		}; 
	}
		};
		
//cout << "END CONVERSION" << endl;

	
