/// 
/// file Macros_StabFem.edp
///
/// This file contains the case-dependent Macros for boundary conditions and postprocessing output.
///
/// This file can be customized according to requirements but it must contain the following macros :
///
/// boundary conditions : 
/// macro BoundaryconditionsBaseFlow(du,u,v) 
/// macro BoundaryconditionsStability(u,v,symmetry)
///
///
/// For post-processsing purposes :
/// macro SFWriteBaseFlow(filename,ux,uy,p,type,iter)
/// macro SFWriteMode(namefile,ux,uy,p,ev,shift,type,iter)
/// 
/// The following case is for the 2D cylinder and include the additional macros
/// required to compute lift and drag forces : Trainee(ux,uy,p,symmetry) and Portance(ux,uy,p,symmetry)


string ffdatadir = "./WORK/";

string symmetryBaseFlow = "S"; // symmetry propery of base flow :; set "S" if domain is hzalf domain and "N" if it is full domain
int bclat=4,bcinlet=1,bcoutflow=3,bcwall=2,bcaxis=6;




macro BoundaryconditionsBaseFlow(du,u,v)
	           on(bcinlet,du#x=1.0-upx,du#y=0.0)
	         + on(bclat,du#y=0.0)  
             + on(bcwall,du#x=0.0,du#y=0.0)
             + int1d(th,bcaxis)(du#x*v#x*1e30*(symmetryBaseFlow=="A")+du#y*v#y*1e30*(symmetryBaseFlow=="S"))       
//EOM

macro BoundaryconditionsStability(u,v,symmetry)
	           on(bcinlet,ux#=0,u#y=0.0)
	         + on(bclat,u#y=0.0) 
             + on(bcwall,u#x=0.0,u#y=0.0)
             + int1d(th,bcaxis)(u#x*v#x*1e30*(symmetry=="A")+u#y*v#y*1e30*(symmetry=="S"))       
//EOM



// HERE ARE SOME MACROS WHICH ARE USEFUL FOR POST-PROCESSING WITH A 2D FLOW OVER A BLUFF BODY

macro Trainee(u,symmetry)   
	(
	(1*(symmetry=="N")+2*(symmetry=="S"))
	*(
	int1d(th,2,21,22,23)(u#p*N.x)
	-nu*int1d(th,2,21,22,23)( (2*dx(u#x)*N.x+(dx(u#y)+dy(u#x))*N.y))
	)
	)
//EOM
	

macro Portance(u,symmetry)   
	(
	(1*(symmetry=="N")+2*(symmetry=="A"))
	*(
	int1d(th,2,21,22,23)(u#p*N.y)
	-nu*int1d(th,2,21,22,23)( (2*dy(u#y)*N.y+(dx(u#y)+dy(u#x))*N.x))
	)
	)
//EOM




macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	if(iter>=0)
	{
	fespace p1forff2m(th,P1);  
	p1forff2m xx,yy;
	xx=x;
	yy=y;
    p1forff2m ut,vt,pt,vort;
	ut=u#x;
	vt=u#y;
	pt=u#p;
	vort=dy(u#x)-dx(u#y); /* vorticity */
	p1forff2m psi,phi;
/*	solve Laplace(psi,phi, solver = CG) */
/* 	= int2d(th)(dx(psi)*dx(phi)+dy(psi)*dy(phi)) */
/* 	- int2d(th)(-vort*phi) */
/* 	- int1d(th,bcinlet,bcoutflow,bclat,bcwall)((-N.x*ux+N.y*uy)*phi); */   
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << typeFlow << endl;
    file << "Format : " << endl;	
	file << "real Re P1 ux P1 uy P1 p P1 vort P1 psi real iter " ;
	string PostProcessBaseFlowDescription = "real Cx real Lx"; /* customizable output */ 
	file << PostProcessBaseFlowDescription << endl << endl ; 
	file << Re << endl;	
			for (int j=0;j<ut[].n ; j++) file << ut[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << pt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vort[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << psi[][j] << endl;
			file << iter << endl;
	
	cout << "#### customisable output for WAKE OF A 2D BLUFF BODY : " << endl; 
    /* Calcul de la trainee */
    real DragMode = Trainee(u,symmetryBaseFlow);
	cout << "#    Cx =  " << 2*DragMode << endl; /* factor 2 because Fx = 1/2 Cx */
    file << 2*DragMode << " " ; 
    
    /* mesure de la longueur de recirculation */
    real Lx, Uap, Uav;
		{
		real dx = 0.001;real Uav = -2e-10;real Uap=-1e-10;int ix;
			for(ix=1;ix<20000;ix++)
			{   
				Uap =ux(0.5+ix*dx,0);
				if(Uap*Uav<0){break;};
				Uav = Uap;	
			}
			real xav = 0.5+(ix-1)*dx; 
			real xap = 0.5+ix*dx;
			Lx = xav *(Uap)/(Uap-Uav) + xap *(-Uav)/(Uap-Uav);
		}	
		cout << "#    Recirculation length = " << Lx << endl << endl; 
		file << Lx << endl;

	}
	}
	else
	{
	ofstream file(filename);
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow NOT CONVERGED" << endl;
    file << "Format : " << endl;	
	file << "int iter " << endl;
	file << -1 << endl;
	};
//EOM
	
	
	
macro SFWriteMode(namefile,u,ev,shift,typeFlow,iter)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1); 
		 p1forff2m xx,yy;
		 xx=x;
		 yy=y;
    	 p1forff2m<complex> ux1,uy1,pp1,vort1;  		 
 		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << typeFlow << endl;
    	 file << "Format :" << endl;
    	 string descriptionFF;
    	 if(typeFlow=="EigenModeD"||typeFlow=="HarmonicMode")
    	 	{  descriptionFF="real Re  complex lambda complex shift int iter P1c ux1 P1c uy1 P1c p1 P1c vort1 real AEnergy complex Cy"; }
    	 else 
    	    {  descriptionFF="real Re  complex lambda complex shift int iter P1c ux1Adj P1c uy1Adj P1c p1Adj P1c vort1Adj real AEnergyAdj complex CyAdj"; }
	     file << descriptionFF << endl << endl ; 
		 file << Re  << endl << real(ev) << " " << imag(ev) << " " << real(shift) << " " << imag(shift) << " " << iter << endl << endl;
 		ux1=u#x;
		uy1=u#y;
		pp1=u#p;
		vort1=dy(u#x)-dx(u#y);
		
		for (int j=0;j<ux1[].n ; j++) file << real(ux1[][j]) << " " << imag(ux1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(uy1[][j]) << " " << imag(uy1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(pp1[][j]) << " " << imag(pp1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(vort1[][j]) << " " << imag(vort1[][j]) << endl;
		
		cout << "#### customisable output for a mode in the WAKE OF A 2D BLUFF BODY : " << endl; 

	
		real AEnergyMode = sqrt(2*int2d(th)(abs(u#x)^2+abs(u#y)^2)); 
		cout << "#   Amplitude (with definition of Mantic-Lugo) = " << AEnergyMode << endl;
		file << AEnergyMode << endl;

		complex LiftMode = Portance(u,"A"); 
		cout << "#   Cy = " << 2*LiftMode << endl;
		file << 2*real(LiftMode) << " " << 2*imag(LiftMode) << endl;
		
		};
//EOM	




//macro PostProcessBaseFlowOutput(file,u1,u2,p)
	